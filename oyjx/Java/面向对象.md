#面向对象
参考：
* 《Java编程思想》 Bruce Eckel著

##0

###Bruce Eckel语录：
当它挡住我们的去路并成为屏障的时候，我们就得跨过去。（他喜欢的喜欢的一句格言：所有模型都是错误的，但有些是能用的。）

“好的程序设计语言能帮助程序员写出好程序，但无论哪种语言都避免不了程序员用它写出了坏程序。”

###几件事、几个点：
* 根据之前数据结构堆栈的学习，写个工具检测文件一些呼应符号是否使用正确，比如“”、《》等

* 弄一个爬虫工具，统计在京东和当当等的总消费（以后可以做些更细致的功能哦）

* 关于设计模式（常用的，适用的）、数据结构（特别是树、散列等）、算法（起码要有排序吧）做一些有意思的功能

* 1230GE6/1230ZHEN6/1230TM6...，能不能继续搞啊（试着用Python）【12306二进制11000000010010】

* 类网易私人FM，但更精准，可参数化（类型，风格，指定/屏蔽歌手，另外能否让用户选择喜欢的旋律/歌词然后匹配曲库的旋律/歌词？）
可以组合各个大型音乐平台（网易云、QQ、酷狗、酷我等？）（侵权问题？）（带上平台logo）

* 文件或文本自动加密上传git的程序

* 关于爬虫
    * 哪些情况下网络爬虫采集数据后具备法律风险
        * 1.当采集的站点有声明禁止爬虫采集或者转载商业化时。
        * 2.当网站声明了rebots协议
            * rebots协议简介
                >Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉爬虫哪些页面可以抓取，哪些页面不能抓取。
                
                >robots.txt文件是一个文本文件，使用任何一个常见的文本编辑器，比如Windows系统自带的Notepad，就可以创建和编辑它。robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。
            
            * 如何查看采集的内容是的有rebots协议
                >其实方法很简单。你想查看的话就在IE上打http://你的网址/robots.txt要是说查看分析robots的话有专业的相关工具 站长工具就可以!
            
            * 如豆瓣：https://www.douban.com/robots.txt
                ```
                User-agent: *
                Disallow: /subject_search
                Disallow: /amazon_search
                Disallow: /search
                Disallow: /group/search
                Disallow: /event/search
                Disallow: /celebrities/search
                Disallow: /location/drama/search
                Disallow: /forum/
                Disallow: /new_subject
                Disallow: /service/iframe
                Disallow: /j/
                Disallow: /link2/
                Disallow: /recommend/
                Disallow: /trailer/
                Disallow: /doubanapp/card
                Sitemap: https://www.douban.com/sitemap_index.xml
                Sitemap: https://www.douban.com/sitemap_updated_index.xml
                # Crawl-delay: 5
                
                User-agent: Wandoujia Spider # 豆瓣和豌豆荚爬虫有仇吗？
                Disallow: /
                
                ```

* 一些特殊用法：
    ```
    // 可以获取启动参数java.util.Arrays.useLegacyMergeSort的值！
    private static final boolean userRequested =
        java.security.AccessController.doPrivileged(
            new sun.security.action.GetBooleanAction(
                "java.util.Arrays.useLegacyMergeSort")).booleanValue();
    
    ```

* 常见疑问：
    * i++ 和 ++i
        ```
        ++i => addAndGet，返回新值（前缀式）
        i++ => getAndAdd，返回旧值（后缀式）
        
        ```
    
    * += 和 +
        ```
        short s_ = 1;
        // s_ = s_ + 1; // 编译错误
        s_ += 1; // 编译通过
        
        原因：
        s_ = s_ + 1，s_ + 1会隐式转换为int型，把int型号赋给short，会造成类型缺失。而s_ += 1相当于s_ = (short)(s_ + 1)会把s_ + 1强制转换为short类型，就不会报错。
        
        ```

    * transient关键字（关闭字段的序列化）
        * 标记transient的字段在序列化的时候，不会保存或恢复该字段值（恢复时会变成null）。

    * circular数组的使用 PipedReader 和 PipedWriter源码
    
    * String、StringBuilder和StringBuffer
        * String：适用于少量的字符串操作的情况
        * StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况
        * StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况
    
* HashMap、ArrayList源码 ConcurrentHashMap、ConcurrentLinkedQueue源码 @Todo（特别是迭达器实现和Map实现（关注MapEntry）、ConcurrentHashMap先了解下怎么实现线程安全的吧）

    1.HashMap源码相关：
    ```
    当然这是简单的实现想法，实际的HashMap并非这样，至少现在并非这样：
    HashMap中的MapEntry其实就是个实现Map.Entry<K,V>的class放着key和value两个参数，实现了getKey()和getValue()方法，另外至于为啥重写hashCode()和equals()（这个要注意下@Todo）。
    entrySet方法就是遍历数组及其里面List（双重循环），然后所有数据放入到Set<Map.Entry<K, V>>类型的set集合（HashSet）中。
    
    JDK 1.8 HashMap通过hashCode匹配数组下标（n是数组长度即桶位，hash为key的hashCode()值）：
    (n - 1) & hash （&能够保证得到的数不会大于n - 1，这个算法比取模好吗）
    if (first.hash == hash && // always check first node
                    ((k = first.key) == key || (key != null && key.equals(k)))) {
    } // 首先hash一定要相等，然后key用equals或者==判断返回true即可（既然==返回true，那一定equals也会返回true，另外允许hash与值相等但非同一对象做key）
    
    
    resize()方法 // 对于阈值（初始时，根据负载因子（默认0.75） * 桶位）设置，而后根据每次都是<<1来设置
    
    if (modCount != mc) // mc为遍历前的modCount
        throw new ConcurrentModificationException(); // 关于遍历时ConcurrentModificationException异常的抛出是根据遍历前的modCount和遍历之后的modCount对比（每一次对HashMap的操作都会维护modCount）
    
    ```
    
    2.HashMap性能相关：
    ```
    容量：表中的桶位数（就是初始的数组长度）；
    初始容量：表在创建时所拥有的桶位数；
    尺寸：表中当前存储的项数（多少个数组已经放上了List）；
    负载因子：尺寸/容量，默认是0.75（达到四分之三满时，才会再散列）
    
    确定数组下标一般通过key的hashCode()取模容量。（大部分现代编译器会尽可能把 2 的 n 次方的乘除法优化为左移右移）（x % y = x − y * (x / y)）
    所以尽可能要有一个好的hashCode()方法，即能够产生分布均匀的散列码。
    result = 37 * result + c;
    P496
    
    ```
    
    3.ArrayList源码相关
    ```
    @Todo
    
    ArrayList的迭代器
    
    public Iterator<E> iterator() {
            return new Itr();
    }
    
    /**
     * An optimized version of AbstractList.Itr
     */
    private class Itr implements Iterator<E> {
        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
        int expectedModCount = modCount;
    
        public boolean hasNext() {
            return cursor != size;
        }
    
        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }
    
        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();
    
            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
    
        @Override
        @SuppressWarnings("unchecked")
        public void forEachRemaining(Consumer<? super E> consumer) {
            Objects.requireNonNull(consumer);
            final int size = ArrayList.this.size;
            int i = cursor;
            if (i >= size) {
                return;
            }
            final Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length) {
                throw new ConcurrentModificationException();
            }
            while (i != size && modCount == expectedModCount) {
                consumer.accept((E) elementData[i++]);
            }
            // update once at end of iteration to reduce heap write traffic
            cursor = i;
            lastRet = i - 1;
            checkForComodification();
        }
    
        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
    
    ```
    
    4.List.toArray() 与 Arrays.asList() 使用时要注意的地方
    ```
    List.toArray()（实际调用的是Arrays.copyOf(elementData, size);）：
    1、List.toArray() 返回Object[]数组，不能强转（强转成基本类型数组编译不通过，强转其他运行时报类型转换错误）
    2、对List.toArray()得到的数组操作，并不会影响原集合，但如果数组项是某个对象，拷贝的是引用的拷贝，那就要注意啦！
    
    Arrays.asList()：
    1、不能对得到的Arrays.adList()集合做新增删除等操作（返回的ArrayList是Arrays的内部类，继承自AbstractList，有些方法没有重写！），如果调用则会抛出java.lang.UnsupportedOperationException异常（子类没有重写相关方法，调用父类AbstractList的相关方法，抛出异常）；
    2、另外注意返回的ArrayList的实现用的数组就是源数组！（数组的修改或者ArrayList修改都会在对方体现）
    
    ```
    
    5.ConcurrentHashMap、ConcurrentLinkedQueue 感觉有些怪异啊（线程安全的实现？） = =
    ```
    @Todo
    
    集合的源码关注迭代器的实现和一些常用方法以及整体的代码结构（包括继承关系，如果能画出类图就很不错了）
    
    ```

* 堆栈信息 OK
    ```
    如何打印堆栈信息
    
    Throwable源码
    
    方法：
    Throwable ex = new Throwable(); // 用Exception也可以吧
    StackTraceElement[] stackElements = ex.getStackTrace();
    
    另外Apache工具类下似乎有提供方法：String fullStackTrace = org.apache.commons.lang.exception.ExceptionUtils.getFullStackTrace(e)
    
    // 这个也可以试试
    Thread.currentThread().getStackTrace();
    
    ```

* null相关
    ```
    null是所有引用类型的默认值；
    null可以强转为任何类型，转换之后instanceof原类型（包括Object）都返回false（null不属于任何类型），同类型null比较都返回true，不同类型编译错误；
    null转强转为某个类可以调用其静态方法不报错，但是调用非静态方法编译通过运行报错（空指针啊）；
    String字符串可以和null相加，null被输出为“null”字符串；
    用八大基本类型转换后的null,不可以进行基本类型的运算,否则会出现编译或者运行错误；
        int i = (Integer)null + 1; // 编译通过，运行时报空指针
        // int i = null + 1; // 编译错误
    null和“”并不相等，“”指向了一块空字符串的内存。
    
    ```

* 类加载相关 @Todo
    ```
    堆、栈、寄存器、内存、缓存
    
    类加载过程
    与编程相关
    其他
    
    ```

* 反射的应用：
    * RMI
    * 注解（读取方法、类、参数、临时变量、构造器等是否有注解以及注解元素）
    * AOP（面向切面编程，应该用到了动态代理）
    * IOC（控制反转/依赖注入）
    * 其他


* JVM相关 @Todo
    * 基本认识
    * 参数意义及其设置
    * 如何排错及如何优化


* Java SE1.8的Lambda表达式及其它新特性 @Todo


* LinkedList和LinkedBlockingQueue

    LinkedList.java
    ```
    /**
     * Removes and returns the first element from this list.
     *
     * @return the first element from this list
     * @throws NoSuchElementException if this list is empty
     */
    public E removeFirst() {
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        return unlinkFirst(f);
    }
    
    /**
     * Retrieves and removes the head (first element) of this list.
     *
     * @return the head of this list, or {@code null} if this list is empty
     * @since 1.5
     */
    public E poll() {
        final Node<E> f = first;
        return (f == null) ? null : unlinkFirst(f);
    }
    
    
    /**
     * Unlinks non-null first node f.
     */
    private E unlinkFirst(Node<E> f) {
        // assert f == first && f != null;
        final E element = f.item;
        final Node<E> next = f.next;
        f.item = null;
        f.next = null; // help GC
        first = next;
        if (next == null)
            last = null;
        else
            next.prev = null;
        size--;
        modCount++;
        return element;
    }
    
    // 定义 final Node<E> f = first用了final，主要是保证后面first的重新赋值不会对f改变？E element = f.item也用了final，防止后面f.item = null影响e吗？
    // f是原first，将其next和item设置为null，帮助GC。
    
    ```
    
    LinkedBlockingQueue.java （用了ReentrantLock（takeLock、putLock）和Condition（notEmpty、notFull阻塞及恢复的实现））
    
    ```
    // 取值时take锁，设值时put锁，队列满了或者空了则阻塞，因为写和读是一头一尾的，取值或者设值时无需同时获取两个锁，不过下面像remove之类的方法就需要了
    /**
     * Removes a single instance of the specified element from this queue,
     * if it is present.  More formally, removes an element {@code e} such
     * that {@code o.equals(e)}, if this queue contains one or more such
     * elements.
     * Returns {@code true} if this queue contained the specified element
     * (or equivalently, if this queue changed as a result of the call).
     *
     * @param o element to be removed from this queue, if present
     * @return {@code true} if this queue changed as a result of the call
     */
    public boolean remove(Object o) {
        if (o == null) return false;
        fullyLock();
        try {
            for (Node<E> trail = head, p = trail.next;
                 p != null;
                 trail = p, p = p.next) {
                if (o.equals(p.item)) {
                    unlink(p, trail);
                    return true;
                }
            }
            return false;
        } finally {
            fullyUnlock();
        }
    }
    
    ```

###jdk包含了以下包：
```
java.*
javax.*
    java和javax都是Java的API(Application Programming Interface)包，java是核心包，javax的x是extension的意思，也就是扩展包。
    java类库是java发布之初就确定了的基础库，而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案，所以，就加上些，典型的就是awt(Abstract Windowing ToolKit) 和swing。
org.*
    java的org包是由企业或者组织提供的java类库。集成到jdk中但大部分不是sun公司的，可以直接使用。其中比较常用的是w3c提供的对XML、网页、服务器的类和接口。

java常见类库：
java.util.*
java.lang.*
java.sql.*
java.io.*
java.nio.*
java.net.*
java.math.*
java.rmi.*

```

###容易读错的词：
Integer Decimal Thread Queue Deque Enum

transaction /trænˈzækʃn/

###新特性

####Java 1.4新特性：
NIO、断言（assert、assertion）

####Java 1.5新特性：
```
1、自动装拆箱（基本数据类型的对象缓存）
2、枚举
3、注解
4、并发类库
5、静态导入（import static语句导入一个类中的某个静态方法或所有静态方法）
6、可变参数
7、增强for循环
8、泛型

```


###设计模式：
分类：
* 创建型模式：这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
    * 工厂模式（Factory Pattern）
    * 抽象工厂模式（Abstract Factory Pattern）
    * 单例模式（Singleton Pattern）
    * 建造者模式（Builder Pattern）
    * 原型模式（Prototype Pattern）
* 结构型模式：这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
    * 适配器模式（Adapter Pattern）
    * 桥接模式（Bridge Pattern）
    * 过滤器模式（Filter、Criteria Pattern）
    * 组合模式（Composite Pattern）
    * 装饰器模式（Decorator Pattern）
    * 外观模式（Facade Pattern）
    * 享元模式（Flyweight Pattern）
    * 代理模式（Proxy Pattern）
* 行为型模式：这些设计模式特别关注对象之间的通信。
    * 责任链模式（Chain of Responsibility Pattern）
    * 命令模式（Command Pattern）
    * 解释器模式（Interpreter Pattern）
    * 迭代器模式（Iterator Pattern）
    * 中介者模式（Mediator Pattern）
    * 备忘录模式（Memento Pattern）
    * 观察者模式（Observer Pattern）
    * 状态模式（State Pattern）
    * 空对象模式（Null Object Pattern）
    * 策略模式（Strategy Pattern）
    * 模板模式（Template Pattern）
    * 访问者模式（Visitor Pattern）
* J2EE模式：这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。
    * MVC 模式（MVC Pattern）
    * 业务代表模式（Business Delegate Pattern）
    * 组合实体模式（Composite Entity Pattern）
    * 数据访问对象模式（Data Access Object Pattern）
    * 前端控制器模式（Front Controller Pattern）
    * 拦截过滤器模式（Intercepting Filter Pattern）
    * 服务定位器模式（Service Locator Pattern）
    * 传输对象模式（Transfer Object Pattern）

Think in Java中提及的设计模式：
* P165：状态模式
    >在运行期获得动态灵活性（调用基类方法的对象可以更改成不同导出类对象，引用都是向上转型为基类，故可以接受不同导出类对象）

* P175、P182、P426、P443、P452：策略模式
    >创建一个能够根据所传递的参数对象的不同（不同的实现类，重写基类方法有不同的行为）而具有不同行为的方法（基类的方法）。

* P177、P183、P424：适配器模式
   * 对象适配器（组合，重写的方法调用组合对象的方法obj.xx()）<br/>
        比如某个方法需要传递一个实现了Addable接口的对象（该接口有个add方法）
        像List集合也有add方法，但没有实现Addable接口，也不可能去实现了，所以可以通过适配器XxAdapter，实现Addable接口，组合List/Collection对象，初始化XxAdapter时传入其实例，重写add()方法，调用List/Collection对象的add()方法实现！
   * 类适配器（继承，重写的方法调用基类的方法，super.xx()）<br/>
        如上例子，适配器也可以实现Addable接口，然后继承List类，重写add()方法，调用super.add()实现（场景不一定适用哈！！！）
   * 接口（适配器实现接口，重写接口方法，这样实现类继承适配器类可以不需要强制重写最顶层接口的的所有方法，可以选择性重写！）<br/>
        比如很多框架都有，可以看看（Spring、Netty）
* P186：工厂模式
    * 通过调用工厂的某个创建方法，生成接口的某个实现的对象。

* P207、P688、P755：模板方法
    * 一些功能在基类中实现，并且其一个或多个抽象方法在派生类中定义（实现）。

* P211、P602：命令模式
    * 一个单一方法的接口，然后从该接口实现具有各自不同的行为的多个子类，之后，然后构造命令对象，并在需要的时候使用它们。
    
    * 比如将命令对象（导出类）向上转型放到集合，然后随时可以调用任何命令执行（调用基类的方法）。
    
    * 好像策略模式啊！

* P337：代理模式
    * 普通代理：通过B方法执行A方法
    
    * 动态代理：可能动态地给任何对象生成代理对象

* P414：装饰器模式 @Todo
    * 装饰器模式使用分层对象来动态透明地向的单个对象中添加责任，装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。

    * 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。
    
    * 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

* P606：职责链模式
    * 遍历责任链，直到链中的某个解决方案能够处理该对象。

    * 日志打印 info => debug => error：<br/>
        依次判断派生类能否处理当前指定级别，不能处理则让下一个级别的派生类来处理。

* P632：访问者模式 @Todo
    * 在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。

    * 根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。
    
    * 主要将数据结构与数据操作分离。
    
    * 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中


* 享元模式
    * “享”就是分享之意，指一物被众人共享，而这也正是该模式的终旨所在。
   
    * 享元模式有点类似于单例模式，都是只生成一个对象来被共享使用。这里有个问题，那就是对共享对象的修改，为了避免出现这种情况，我们将这些对象的公共部分，或者说是不变化的部分抽取出来形成一个对象。这个对象就可以避免到修改的问题。
    
    * 享元的目的是为了减少不会要额内存消耗，将多个对同一对象的访问集中起来，不必为每个访问者创建一个单独的对象，以此来降低内存的消耗。
    
    * 享元模式使用的场景：<br/>
        当我们项目中创建很多对象，而且这些对象存在许多相同模块，这时，我们可以将这些相同的模块提取出来采用享元模式生成单一对象，再使用这个对象与之前的诸多对象进行配合使用，这样无疑会节省很多空间。
    
    * 享元与单例的区别：<br/>
        享元设计模式一个类可以有很多对象（保存到集合中，根据不同需求获取，如果下次是同一需求那共享之前的），而单例是一个类仅一个对象！

* 观察者模式
    * 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。


* 迭代器模式
    * 迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
    
    * 内部类实现，常见集合类源码

* 桥接模式
    * 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

    * 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。


##Think in Java：

###概览
（1、
3\5\6（操作符、初始化与清理、控制权限限制）

（2、
7\8\9\10（复用类、多态、接口、内部类）


（3、
12\13\16\19（异常、字符串、数组、枚举）

（4、
14（反射）
15（泛型）
20（注解）

（5、
18（I/O）

（6、
11\17（容器） hash 一些常用容器及常用方法 容器间优缺点等 源码

（0、
21（并发）
还需多看相关数据比如《Java Concurrency in Practice》等
另外自己尝试编写相关程序


###3、操作符
可以看下oyjxDemo下com.original.java.base.OperatorDemo.java


###5、初始化和清理：
####构造器

####方法重载
* 创建一个对象，也就是给对象分配到的存储空间取了一个名字；所谓方法则是给某个动作取的名字。

* 构造器重载、方法重载
    * 每个重载方法都有独一无二的参数类型列表（数量和类型），注意光是返回值不同是不行的！

* 重写：
    * 1.方法重写时，方法名与形参列表必须一致。
    * 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。
    * 3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。（需与父类方法返回值类型一致或者其类型子类）
    * 4.方法重写时，子类抛出的异常类型要小于或者等于父类抛出的异常类型。（Exception(最坏) RuntimeException(小坏)）

####this关键字：
* 对于将当前对象传递给其他方法和有用：
    ```
    class Obj {
        ...
        Obj fun() {
            ...
            return this; // 将调用此方法的对象返回
        }
        ...
    }
    
    Obj obj = new Obj();
    obj.fun().fun().fun(); // 这样就可以连续调用某方法了
    
    例如：StringBuffer sb = new StringBuffer(""); sb.append("1").append("2");
    
    ```

* 在构造器中调用构造器
    ```
    int petals;
    String name = "default name";
    Flower(int petals) {
        this.petals = petals;
    }
    
    Flower(String name, int petals) {
        this.name = name; // 形式参数和成员变量同名时，加上this表示成员变量
        this(petals); // 调用只有一个int参数的构造器
    }
    ```

* 形式参数和成员变量同名时
    ```
    int i = 0;
    
    public void x(int i) {
    
        System.out.println(i);
        System.out.println(this.i);
        this.i = i;
        System.out.println(i);
        System.out.println(this.i);
    }
    ```

* static的含义：
    * static方法就是没有this的方法。像是全局方法，可有访问其他static方法和static域（不能访问非静态方法和域，当然你可以传入对象的引用作为参数，那就可以访问了）。


####清理：终结处理和垃圾回收

* finalize()的用途何在
    * 对象可能不被垃圾回收；
    * 垃圾回收并不等于“析构”；（析构函数是一种在对象被销毁时可被自动调用的函数）
    * 垃圾回收只与内存有关。

* finalize()只用于释放调用了本地方法分配的存储空间！

* finalize()有趣的一个用法：
    * 对象终结条件的验证 @Todo

* 垃圾回收器（GC：Garbage Collector）如何工作：
    * P89 @Todo 参考《深入理解Java虚拟机》


####成员初始化
* Java尽力保证：所有变量在使用前都能得到恰当的初始化。

* 方法的局部变量如果没有初始化就操作则会得到编译错误；
* 类的成员变量则会保证都会有一个初始值：
    ```
    boolean false
    char 空白（为0，所以显示空白，可以打印“(char) 0”看下）
    byte 0
    short 0
    int 0
    long 0
    float 0.0
    double 0.0
    reference（对象引用） null
    
    ```

####构造器初始化
* 可以用构造器来进行初始化，在运行时刻，可以调用方法或执行某些动作来确定初值，这为编程带来了更大的灵活性。但要牢记：无法阻止自动初始化的进行，它将在构造器被调用之前发生。

* 初始化顺序：
    * 在类的内部，变量定义的先后顺序决定了初始化的顺序，即便变量定义散步于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。

* 静态数据的初始化：
    * 无论创建多少个对象，静态数据都只占用一份存储区域（只会初始化一次）。static关键字不能应用于局部变量，因此它只能作用于域。
    * 如果一个域是静态的基本类型域，且没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始值就是null。

* 对象的创建过程，假设有个名为Dog的类：P96

* 显式的静态初始化：
    * 静态子句，也称静态块，与其他静态化初始动作一样，这段代码仅执行一次：当首次生成这个类的一个对象或者首次访问属于那个类的静态数据成员时（即便从未生成过那个类的对象）。

* 记住一点：如果不生成对象，仅仅是访问类的静态数据成员，则只会执行静态成员和子句的一次初始化（也是唯一一次），非静态数据成员（变量和子句）和构造器都不会初始化和执行（除非像StaticResourceLoadDemo.java中的静态域是new当前对象）

* P96里的第1点好像有疑问哦！

* 特殊点：初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行（就是说如果仅是调用静态常量是不会引发其他静态域和静态代码块初始化的）（参考StaticResourceLoadDemo.java）


* 非静态实例初始化：
    * 非静态化子句，使得无论调用哪个显式构造器，某些操作都会发生，并在构造器之前执行。

* 注意执行main方法其实也是当前类的静态方法！如果当前类有基类、域与代码块（不管是否静态）、构造器，都需要依次处理！

* 关于构造器初始化相关示例，特别是涉及继承，以及一些比较变态的地方
    * @Todo 可以看下oyjxDemo下com.original.java.base.classLoad.StaticResourceLoadDemo.java

####数组初始化
```
int[] a;
int a[];

初始化：
int[] a1 = {1, 2, 3, 4, 5};
int[] a2;
a2 = a1; // 注意，这仅仅只是复制了一个引用！对a2进行操作会同时影响原数组a1。

int[] a = new int[20]; // 创建一个长度为20的数组，数组元素中的基本数据类型会被初始化成空值（对于数字和字符，就是0；对于布尔类型，就是false）

Integer[] a = new Integer[20]; // 对于非基本类型的数组，这这是创建了一个引用，只有创建对象赋值给引用之后才算初始化完成。

// 如果非基本类型的数组没有创建对象，试图使用数组中的空引用，就会在运行时产生异常（取到的是null）。

Integer[] a = {
    new Integer(1),
    new Integer(2),
    3 // Autoboxing
};
Integer[] a = new Integer[]{
    new Integer(1),
    new Integer(2),
    3 // Autoboxing
};

```

####可变参数列表：P102


###6、访问和控制权限：

####包：库单元
P110

####Java访问权限修饰词
* public （接口访问权限）任何包
* protected （继承访问权限）同一个包和不同包的子类
    * “就类用户而言，这是private的，但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的”
* default （包访问权限）同一个包
* private 其它类都无法访问

####接口和实现

####类的访问权限
* 非内部类，只能是public或者是包访问权限，当然一个编译单元（.java文件）只能有一个且必须要有一个public类。
    ```
    class Demo {
        private Demo() {};
        public static Demo getDemo() {
            // 这样只能通过此方法创建对象，可以在返回对象前做些额外的工作，也可以记录对象创建的次数（可能要限制其次数等）
            return new Demo();
        }
    }

    ```

* 如果没有为一个类访问权限指定为一个访问修饰符，它就会默认得到包访问权限，这就意味着该类的对象可以由包内任何其他类来创建看，但是在包外则是不行的。

* 一定要记住，相同目录下的所有不具有明确package声明的文件，都被视作是该目录下默认包的一部分。（就是直接仍在src的默认包下）

* P123有一个疑问点



###7、复用类
组合：秩序在新的类中产生现有类的对象

继承：按照现有类的类型来创建新类

####组合
* 只需将对象引用置于新类中即可。

* 初始化引用可以在以下位置：
    * 1、在定义对象的地方（在构造器被调用之前被初始化）
    * 2、在类的构造器中
    * 3、在正要使用这些对象之前（惰性初始化）
    * 4、使用实例初始化 @Todo

####继承 extends

* 为了继承，一般的规则是将所有的数据成员都指定为private，将所有的方法指定为public（保留“更改底层实现”的权利）。当然特殊情况下必须做出调整。

* 初始化基类：
    * Java会自动在导出类的构造器中插入对基类构造器的调用。

* 带参数的构造器：
    * 如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须用关键字super显式地调用基类构造器的语句，并且配以适当的参数列表。
    * 若不需要加super而未加的话则编译失败。

* 可以看些源码，比如容器的等，可能存在很多层继承的情况，并且可能构造器很多！@Todo


####代理
* 继承与组合的中庸之道。因为我们将一个成员置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该成员对象的所有方法（就像继承）。
    * P131

* 具体场景：@Todo


####结合使用组合和继承

* 确保正确清理：
    * 如果你想要某个类清理一些东西，就必须显式地编写一个特殊方法来做这件事，可以将这一清理动作置于finally子句之中，以预防异常的出现。
    * 注意：需要考虑对基类清理方法和成员对象清理方法的调用顺序，以防某个子对象依赖于了；另一个子对象情形发生。（一般来说同生成顺序相反）

* 名称屏蔽：
    * 如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（这一点与C++不同）。

* @Override注解，防止不想重载时而意外地进行了重载（该注解表明一定是重写！）


####组合与继承之间的选择 P137

* 组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形。（即在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口）

* 在继承的时候，使用某个现有类，并开发一个它的特殊版本。（通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化）

* “is-a”（是一个）的关系是用继承来表达的，而“has-a”（有一个）的关系则是用组合来表达的。
    * 比如：“车子”是“交通工具”，但“车子”并不包含“交通工具”！

* 一般来说，继承技术其实是不太常用的，应当慎用这一技术。

* 到底是继承还是组合，可以问一问自己“是否需要从新类向基类进行向上转型？”，如果需要，继承是必要的，如果不需要，则应当好好考虑自己是否需要继承。


####向上转型
* 对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。

* “为新类提供方法”并不是继承技术中最重要的方面，其最重要的方面是用来表现新类和基类之间的关系（“新类是现有类的一种类型”）

* 传统的类继承图的绘制方法：将根置于页面的顶端，然后逐渐向下。

* 由于导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型。（一个较专用类型向较通用类型转换，所以总是安全的，不过类接口中唯一可能发生的事情就是丢失方法）


####final关键字
* final通常指的是“这是无法改变的”，不想做出改变的理由：设计和效率（懒）。


* 1.final数据
    * 1、一个用不改变的编译时常量
    * 2、一个在运行时被初始化的值，而你不希望它被改变

    * 一个既是static有时final的域只占据一段不能改变的存储空间（编译器常量）。

    * 注意数据是final不能认为在编译时就可以直到它的值。

    * 对基本类型运用final时，final使数值恒定不变；
    * 对对象引用运用final时，final使引用恒定不变（一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象，然而对象自身是可以修改的，这同样适用于数组）。

    * 空白final：声明为final，但是又未给定初值的域。不过无论什么情况，编译器都能确保空白final域使用前必须被初始化。
    * 空白final在关键字final的使用上提供了更大的灵活性，为此，一个类中的final域就可以做到根据对象而有所不同，却又保持其恒定不变的特性。
    * P142 利用不同构造器可以对final域进行不同的初始化。

    * final参数：Java允许在参数列表中以声明的方式将参数指明为final，这意味着你无法在方法中更改参数引用所指向的对象。
    * 这一特性常用于向匿名内部类传递数据。


* 2.final方法
    * 两个原因：
        * 1、把方法锁定，以防止任何继承类修改它的含义（行为保持不变，且不被覆盖）
        * 2、效率（早期Java实现）

    * 只有在想要明确禁止覆盖时，才将方法设置为final的！

    * final和private关键字：
        * 类中所有的private方法都隐式地指定为final的，由于无法取用private方法，所以也就无法覆盖它。


* 3.final类
    * 表明了你不打算继承该类，而且也不允许别人这么做（类中的所有方法都隐式指定为是final的）。
    * 换句话说，处于某种考虑，你对该类的设计永不需要做任何改动，或者出于安全的考虑，你不希望它有子类。


####初始化及类的加载
* 类的代码在初次使用时才加载。这通常是指加载发生于创建类的第一个对象之时，但是当访问static域或static方法时，也会发生加载。
* 初次使用之处也是static初始化发生之处，所有的static对象和static代码段都会在加载时依程序中的顺序（即，定义类时的书写顺序）而依次初始化，并只初始化一次。

* P146
* 类加载顺序注意点：
    * 访问static域或者方法以及创建对象（也可以看出是调用static方法），先是将基类的和导出类的static域和代码块加载完，如果创建对象，接下来将基类的非static域和代码块以及构造器，再到子类的。
* 注意点：
    * 基类到导出类的static域和代码块加载完，才会执行基类到导出类的构造器！
    * 如果先是访问基类的静态域的成员或者方法以及创建对象，不会处理导出类（子类）的初始化！

* 特殊的一点：参考oyjxDemo下的com.original.java.base.classLoad.StaticResourceLoadDemo.java


###8、多态（也称动态绑定、后期绑定或运行时绑定）
* 多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。（多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序——即无论在项目最初创建时还是在需要添加新功能时都可以“生长”的程序）

* “封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离出来。
* 而多态的作用则是消除类型之间的耦合关系。
* 继承允许将对象视为它自己本身的类型或其基类型来加以处理，这种能力极为重要，因为它允许将多种类型（从同一基类导出的）视为同一类型来处理，而同一份代码也就可以毫无差别地运行在这些不同的类型之上了。
* 多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出而来的。这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。

####再论向上转型

####转机

* 1.方法调用绑定
    * 将一个方法调用同一个方法主体关联起来被称为绑定。
    * 若程序在执行之前绑定（如果有的话，由编译器和连接程序实现），叫做前期绑定。
    * 运行时根据对象的类型进行绑定，叫做后期绑定，也叫动态绑定或运行时绑定。

    * Java中除了static方法和final方法（private方法属于final的）之外，其他所有的方法都是后期绑定。这就意味着通常情况下，我们不必判断是否应该进行后期绑定——它们会自动发生。

* 2.产生正确的行为所有
    * 经典例子“几何形状”
    * P151

* 3.可扩展性

* 4.缺陷：“覆盖”私有方法
    * 只有非private方法才可以被覆盖。在导出类中，对于基类中的private方法，最好采用不同的名字。

* 5.缺陷：域与静态方法
    * 只有普通的方法调用可以是多态的。如果直接访问某个域，这个访问就将在编译期进行解析，如果某个方法是静态的，它的行为就不具有多态性，静态方法是与类，而并非与单个的对象相关联的。
    * P156

####构造器与多态
尽管构造器并不具有多态性（实际上是static方法，只不过该static声明是隐式的），但还非常有必要理解构造器怎样通过多台在复杂的层次结构中运作。

* 1.构造器的调用顺序
    * P158

    *首先要调用基类构造器的原因：在构造器内部，必须确保所要使用的成员都已经构造完毕

* 2.继承和清理
    * 通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行处理。
    * 如果确实遇到清理的问题，那么必须用心为新类创建dispose()方法。并且由于继承的缘故，如果有其他作为垃圾回收一部分的特殊清理动作，那就必须在导入类中覆盖dispose()方法，当覆盖被继承类的dispose()方法时，务必记住调用基类版本dispose()方法；否则，基类的清理动作就不会发生。
    * 万一某个子对象要依赖于其他对象，销毁的顺序应该和初始化顺序相反。
    * P159

    * 如果成员对象中存在与其他一个或多个对象共享的情况，问题就变得更加复杂了，就不能简单地假设你可以调用dispose()了，也许可以引入引用计数来跟踪仍旧访问着共享对象的对象数量了。
    * P161

* 3.构造器内部的多态方法的行为
    * 构造器调用的层次结构带来了一个有趣的两难问题：如果在一个构造器的内部调用正在构造的对象的某个动态绑定方法，那会发生什么呢？
    * 基类对象在进行初始化，导出类还没有被初始化，如果动态绑定调用到导出类的方法里依赖于导出类的初始化，那就会出问题，不过至少程序不会报错，比如方法引用的成员变量需在构造时初始化，那么在基类的构造器调用动态绑定的该方法时，成员变量只能取到默认初始值了。

    * 因此，编写构造器时有一条有效的准则：“用尽可能简单的方法使对象进入正常状态；如果可以的话避免调用其他方法”。（调用final方法是安全的）

####协变返回类型
* 导出类的被覆盖方法可以返回基类方法的返回类型的某种导出类型。
* P164

####用继承进行设计
* 更好的方式是首先选择“组合”，尤其是不能十分确定应该使用哪一种方式是。组合不会强制我们的程序设计进入继承的层次结构，而且，组合更加灵活，因为它可以动态选择类型（因此也就选择了行为）；相反，继承在编译时就需要知道确切类型。

* “用继承表达行为间的差异，并用字段表达状态上的变化”
* P165

* 1.纯继承与扩展
    * 纯继承：只有在基类中已经建立的方法才可以在导出类中被覆盖。纯粹的“is-a”（是一种）关系。也可以认为是纯替代。

    * 扩展接口：“is-like-a”（像一个）关系，导出类就像是一个基类——它有着相同的基本接口，但是它还具有由额外方法实现的其他特征。
        * 虽然这是一种有用且明智的方法（依赖于具体情况），但是它也有缺点，导出类中接口的扩展部分不能被基类访问，因此，一旦我们向上转型，就不能调用那些新方法。

* 2.向下转型与运行时类型识别
    * 由于向上转型会丢具体的类型信息，所以我们想通过向下转型获取类型信息。
    运行时类型识别（RTTI）
    * P167


###9、接口

接口（USB接口：interface 各种数据线-implements）（如果是一个很纯粹的极度抽象的接口）
抽象类（好像用上面的例子更合适，USB接口应该有自己的功能- -）
电脑接口：电源接口、网线接口、USB接口、耳麦接口... 【可以抽象成一个类或者接口，具体实现就是各个接口自己的功能了】

接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。

####1.抽象类：普通的类与接口之间的一种中庸之道
* 尽管在构建具有某些未实现方法的类时，你的第一想法可能是创建接口，但是抽象类仍旧是用于此目的的一种重要而必须的工具，因为你不可能总是使用纯接口。

* 抽象方法：仅有声明而没有方法体，abstract void f();

* 包含抽象方法的类叫做抽象类，如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。

* 无法从抽象类创建对象！

* 如果从一个抽象类继承，并想创建该类的对象，那么就必须为基类中的所有抽象方法提供方法定义，如果不这样做，那么导出类便也是抽象类，且编译器将会强制我们用abstract关键字来限定这个类。

* 我们可以创建一个没有任何抽象方法的抽象类。如果一个类包含任何abstract方法都显得没有实际意义，而且我们也想要阻止产生这个类的任何对象，那么这时这样做就很有用了。

####2.接口
* interface关键字使抽象的概念更向前迈进一步了。interface这个关键字产生一个完全抽象的类，根本就没有提供任何具体实现。

* 一个接口表示：“所有实现了该特定接口的类看起来都像这样”。接口用来建立类与类之间的协议。（某些面向对象的编程语言用关键字protocol来完成这一功能）

* interface不仅是一个极度抽象的类，它允许通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继承变种的特性。

* 接口中定义的方法必须被定义为public的，可以不显式加public关键字，但它还是public的。

####3.完全解耦
* P175 策略模式、适配器模式

* 将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现，因此代码也就更具可复用性。

####4.Java中多重继承
* 人（基类，有人的基本行为）
* 画家（接口，定义画画）
* 作家（接口，定义写作）
* ...

* 定义一个“艺术家”，创建一个类，首先继承“人”，有了作为人最基本的行为，然后如果实现了“画家”、“作家”等接口，那么这个人就可以升级为艺术家了。

* 使用接口的原因；
    * 1、为了能够向上转型为多个基类（以及由此而带来的灵活性）
    * 2、防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口（与使用抽象基类相同）

* 是选择接口还是抽象类呢？
    * 如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。事实上，如果知道某事物应该成为一个基类，那么第一选择应该是使它成为一个接口。

####5.通过继承来扩展接口
* 通过继承很容易在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。extends可以用于单一类，也可以引用多个基类接口。
* P180

* 组合接口时的命名冲突：
    * 如果实现的接口和继承的基类有重名的方法？（如果基类的非抽象方法，则导出类可以不用重写，尽管实现的接口有该方法，但注意权限修饰符哦，接口的方法是隐式的public）
    * 如果两个方法的签名或返回值不同呢？ 比如接口A继承的接口B和C有同名的方法，仅返回值不同，是不行的，编译失败；或者类A继承的基类B和实现的C接口有同步但仅仅返回值不一样的方法，也会导致编译失败！
* P181

* 在打算组合的不同接口中使用相同的方法名通常会造成代码可读性的混乱，请尽量避免这种情况。

####6.适配接口
* 接口最吸引人的原因之一就是允许同一接口具有多个不同的具体实现。
* 接口常见用法就是策略设计模式，编写一个执行某些操作的方法，而该方法将接受一个同样是你指定的参数，“你可以用任何你想要的对象来调用我的方法，只要你的对象遵循我的接口”。
* P182

####7.接口中的域
* 放入接口中的任何域都自动是static和final的，所以接口就成为了一种很便捷的用来创建常量组的工具。
* Java SE5之后，可以使用更加强大而灵活的enum关键字。

* 初始化接口中的域：
    ```
    在接口中定义的域不能是“空final”，但是可以被非常量表达式初始化，例如：
    public interface Demo {
        Random RAND = new Random(47);
        int RANDOM_INT = RAND.nextInt(47);
        float RANDOM_FLOAT = RAND.nextLong() * 10;
        ...
    }
    ```

* 既然域是static的，那么它们就可以在类第一次被加载时初始化，这发生在任何域首次被访问时。

* 当然，这些域不是接口的一部分，它们的值被存储在该接口的静态存储区域内。

####8.嵌套接口
* 接口可以嵌套在类或其他接口中（接口中嵌套的接口必须是public，当然可以不必显式声明）。
* P185

* 相关：
    * 1、实现一个private接口只是一种方式，它可以强制该接口中的方法定义不要添加任何类型信息（也就是说，不允许向上转型）
    * 2、一个返回对private接口引用的方法，得到的返回值只能交给有权使用的对象使用。
        ```
        class A {
            private interface D {
                void f();
            }
        
            public class DImp implements D {
                public void f() {}
            }
        
            public D getD() {
                return new DImpl()
            }
        
            public D dRef;
            public void receiveD(D d) {
                dRef = d;
                dRef.f();
            }
        }
        ... // main
        A a = new A();
        // A.D ad = a.getD(); // 编译错误
        // A.DImpl di = a.getD(); // 编译错误
        // a.getD().f(); // 编译错误
        A a2 = new A();
        a2.receiveD(a.getD()); // OK

        ```
    * 3、当实现某个接口时，并不需要实现嵌套在其内部的任何接口。而且private接口不能在定义它的类之外被实现。
        ```
        interface E {
            interface G {
                void f();
            }
        
            void g();
        
            // 编译错误，接口中嵌套的接口必须是public
            // private interface I {
            //}
        }
        
        class EImp implements E {
            // 只要实现E接口下面的方法g()即可，不需要实现E接口嵌套的接口的方法
            public void g() {}
        }
        
        class EGImp implements E.G {
            // E接口嵌套的接口的方法只有在该嵌套接口被实现时才要实现
            public void f() {
            }
        }

        // 这样也可以！
        class EGImp2 implements E {
            public void g() {
            }
        
            class EG implements E.G {
                public void f() {
                }
            }
        }

        ```

####9.接口与工厂
* 接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂方法设计模式。
* 这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。理论上，通过这种方式，我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换另一个实现。
* P187

####10.总结
* 任何抽象性都应该是应正真的需求而产生的。
* 恰当的原则应该是优先选择类而不是接口。从类开始，如果接口的必需性变得非常明确，那么就进行重构。接口是一种很重要的工具，但是它们容易被滥用。


###10、内部类
可以将一个类的定义放在另一个类的定义内部，这就是内部类。

内部类允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。必须要了解：内部类与组合是完全不同的概念！

内部类不仅仅是将类置于其他类的内部，而且它了解外围类，并能与之通信；而且用内部类写出的代码更加优雅而清晰，尽管并非总是如此。

####1.创建内部类
* P190-P191

* 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么需要具体地指明这个对象的类型：OuterClassName.InnerClassName！

####2.链接内部类
* 当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。
* 此外，内部类还拥有对其外围类的所有元素的访问权。

* P192
* 内部类可以访问其外围类的方法和字段，就像是自己拥有它们似的。内部类自动拥有对其外围类所有成员的访问权，怎么做到的呢？
* 当一个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用！（而且编译器会帮忙处理这些细节）
* 注意：内部类对象只能在与其外围类的对象相关联的情况下才能被创建（在内部类是非static时）

####3.使用.this和.new
* 如果你需要生成一个对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译器就被知晓并受到检查，因此没有任何运行时开销。

* 有时你可能想要告知某些其他对象，去创建其某个内部类的对象，你必须在new表达式中提供对其他外部类对象的引用，这是需要使用.new语法。
    ```
    DotNew dn = new DotNew(); // 外围类
    DotNew.Inner dni = dn.new Inner(); // 通过外部类引用dn.new创建内部类Inner对象
    // DotNew.Inner dni = dn.new DotNew.Inner(); // 不能这样哦

    ```
* 注意：必须使用外部类的对象来创建该内部类的对象，在拥有外部类对象之前是不可能创建内部类对象的，这是因为内部类对象会暗暗地连接到创建它的外部类对象上。
* 如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用了。

* 另外如果内部类指定为private或者包访问权限或者protected，创建内部类对象是要受到限制的。

####4.内部类和向上转型
* 当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地（从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的）。
* 这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。
* P194

* 注意下private的内部类，是不可以通过外围类引用.new的方式创建对象的！并且，通过外围类名称.内部类名称都是不可以的，通过外围类方法返回的对象只能用基类引用接收。

* private内部类给类的设计者提供了一个途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。
* 此外，从客户端程序员的角度来看，由于不能访问任何新增加的、原本不属于公共接口的方法，所以扩展接口是没有价值的。

####5.在方法和作用域内的内部类
* 内部类的语法覆盖了大量其他的更加难以理解的技术。

* 可以在一个方法或者任意的作用域内定义内部类的理由：
    * 1、如前所示，实现了某类型的接口，于是可以创建并返回对其的引用；
    * 2、你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。

* 一些实现：
    * （1、一个定义在方法的类（局部内部类）
    * （2、一个定义在作用域内的类，词作用域在方法的内部
    * （3、一个实现了接口的匿名类
    * （4、一个匿名类，它扩展了有非默认构造器的类
    * （5、一个匿名类，它执行字段初始化
    * （6、一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）

* P196

* 被嵌入子在if语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然后在定义该内部类的作用域之外，它是不可用的，除此之外，它和普通的类一样！

####6.匿名内部类
* P197
* 方法将返回值的生成和表示这个返回值的类的定义结合在一起。
* “创建一个继承自Xx的匿名类的对象”，通过new表达式返回的引用被自动向上转型为对Xx的引用。

* 匿名内部类可以使用默认的构造器（无参）来生成，如果基类需要一个有参数的构造器，那么简单地传递合适的参数给基类的构造器即可。

* 如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的。如果参数是传递给匿名类的基类构造器而非子啊匿名内部类内部被直接使用的，是不需要定义成final的。

* 如果想做一些类似构造器的行为，该怎么办呢？在匿名内部类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果：
    ```
    public Base getBase(int i, final float price) {
        return new Base(i) {
            private int cost;
    
            {
                ... // doing something for initialize.
                cost = Math.round(price); // 因为匿名内部类中使用到了price，所以方法的形参要定义为final，而参数i只是传递给Base的构造器，所以不需要！
                if (cost > 100) {
                    System.out.println("Over budget!");
                }
            }
    
            publci void f() {}
        };
    }
    ```
* 在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分来执行（就是if语句）。
* 所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制——你不能重载实例初始化方法，所以你仅有一个这样的构造器。

* 匿名内部类与正规的继承相比有些缺陷，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口！


* 再访工厂方法：
* P199
* 在实现类中定义静态方法返回工厂对象（返回的工厂对象指向工厂基类，方法使用匿名内部类构造工厂并提供获取实现类实例的方法）

####7.嵌套类
* 如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为“嵌套类”。
* 普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然后，当内部类是static时，就不一样了。
* 嵌套类意味着：
    * （1、要创建嵌套类的对象，并不需要其外围类的对象；
    * （2、不能从嵌套类的对象中访问非静态的外围类对象。

* 嵌套类和普通的内部类还有一个区别：普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西。

* P202

* 接口内部的类：
    * 正常情况下，不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分。放到接口中的任何类都自动地是public和static的，因为类是static的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。
    * 甚至可以在内部类中实现其外围接口。
    * P202

* 从多层嵌套类中访问外部类的成员：
    ```
    一个内部类被嵌套多少层并不重要——它能透明地访问所有它锁嵌入的外围类的所有成员。
    class MNA {
        private void f() {}
        class A {
            private void g() {}
            public class B {
                void h() {
                    g();
                    f();
                }
            }
        }
    }

    main:
    MNA mna = new MNA();
    MNA.A mnaa = mna.new A();
    MNA.A.B mnaab = mnaa.new B();
    mnaab.h(); // 调用了A类的g()和MNA类的f()方法，尽管它们都是private的
    
    ```

####8.为什么需要内部类
* 使用内部类最吸引人的原因是：
* 每个内部类都能独立地继承子一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响
* 从这个角度看，内部类使得多重继承的解决方案变得完整，接口解决了部分问题，而内部类有效地实现了“多重继承”，也就是说，内部类允许继承多个非接口类型（类或抽象类）

* 如果使用内部类，还可以获得其他一些特性：
    * （1、内部类可以有多个实例，每个实例都有自己的状态信息，并且与外围类对象的信息相互独立；
    * （2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类；
    * （3、创建内部类对象的时刻并不依赖于外围类对象的创建；
    * （4、内部类并没有令人迷惑的“is-a”关系；它就是一个独立的实体。


* 闭包和回调：
    * 闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。
    * 内部类是面向对象的闭包，因为它不仅包含对外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。

* 为什么Java没有包含某种类似指针的机制，以允许回调（callback）？
* 通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。

* 通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。
* P206


* 内部类和控制框架：
    * 应用程序框架就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个类或多个类，并覆盖某些方法。在覆盖方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题。（模板方法设计模式）

* 控制框架是一类 特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应时间的系统称为事件驱动系统（Java Swing库）。

* P208 GreenHouseControls
* “变化向量”就是各种不同的Event对象所具有的不同行为，而你通过创建不同的Event子类来表现不同的行为。
* 这正是内部类要做的事情，内部类允许：
    * （1、控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必须的各种不同的action()；
    * （2、内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。

####9.内部类的继承
* 因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。
* 问题在于，那个指向外围类对象的“秘密的”引用必须被初始化，而在导出类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关系：
    ```
    class WithInner {
        class Inner {}
    }
    
    public class InheritInner extends WithInner.Inner {
        InheritInner(WithInner wi) {
            wi.super();
        }
        public static void main(String[] args) {
            WithInner wi = new WithInner();
            InheritInner ii = new InheritInner(wi);
        }
    }
    
    可以看出，InheritInner只继承自内部类，而不是外围类，但是当要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外围类对象的引用。
    此外，必须在构造器内使用如下语法：
        enclosingClassReference.super(); // 外围类对象的引用.super()
    这样才提供了必要的引用，然后程序才能编译通过。
    ```

####10.内部类可以被覆盖吗
* 如果创建了一个内部类，然后继承其外围类并重新定义此内容时，会发生什么呢？也就是说，内部类可以被覆盖吗？
* 但是“覆盖”内部类就好像它是外围类的一个方法，其实并不起什么作用。
* P212
* 当继承被了某个外围类的时候，内部类并没有发生什么特别神奇的变化，这两个内部类是完全独立的两个实体，各自在自己的命名空间内。
* 当然明确地继承某个内部类也是可以的：
    * P213

####11.局部内部类
* 前面提到过，可以在代码块了创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。
* P214

* 使用局部内部类而不是使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象！

####12.内部类标识符
* 由于每个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个“meta-class”，叫做Class对象）。
* 内部类也必须生成一个.class文件以包含它们的Class对象信息。此类文件的命名有严格的规则：外围类的名字，加上“$”，在加上内部类的名字。
* 例如，LocalInnerClass.java生产的。class文件包含：
    ```
    Counter.class
    LocalInnerClass$1.class // 匿名内部类
    LocalInnerClass$1LocalCounter.class
    LocalInnerClass.class
    P214
    ```
    
* 如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加载其外围类标识符与“$”的后面。

* 虽然这种命名格式简单而直接，但还是很健壮的，足以应对绝大多数情况。因为这个是Java的标准命名方式，所以产生的文件自动都是平台无关的。（注意，为了保证你的内部类能起作用，Java编译器会尽可能地转换它们。）

* 具体更详细的参考oyjxDemo下com.original.java.base.InnerClassDemo.java

####13.总结
* 目标：清楚地识别什么情况下应该使用接口，什么情况使用内部类，或者两者同时使用。


###12、异常
Java的基本理念是“结构不佳的代码不能运行”

要想创建健壮的系统，它的每一个构建都必须是健壮的。

####1.基本概念
* Java使用异常来提供一致的错误报告模型，使得构件能够与客户端代码可靠地沟通问题。

* 使用异常带来的明显好处是，它往往能够降低错误处理代码的复杂度。

####2.基本类型
* 异常情形是指阻止当前方法或作用域继续执行的问题。

* 我们可以把异常看作是一种内建的恢复（undo）系统。

* 异常最重要的方面之一是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去。

* 参数异常：
    * 所有标准异常类都有两个构造器：一个是默认构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器：throw new NullPointerException("t = null");

* 关键字throw将产生许多有趣的结果，在使用new创建了异常对象之后，此对象的引用将传给throw。
* 另外还能用抛出异常的方式从当前的作用域退出。
* 在这两种情况下，将会返回一个异常对象，然后退出方法或作用域。

* 此外，能够抛出任意类型的Throwable对象，它是异常类型的根类。

####3.捕获异常
* 监控区域：
    * 一段可能产生异常的代码，并且后面跟着处理这好像这些异常的代码。

* try块：
    * 要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。

* 异常处理程序：
    * 抛出的异常必须子啊某处得到处理，这个“地点”就是异常处理程序，而且针对每个要捕获的异常，都得准备相应的处理程序。
    * 异常处理程序紧跟在try块后面，以关键字catch表示：
    ```
    try {
        // Code that might generate exceptions
    } catch(Type1 id1) {
        // Handle exception of Type1
    } catch(Type2 id2) {
        // Handle exeeption of Type2
    }
    ```

* 异常处理程序必须紧跟在try之后。当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。

* 终止与恢复：
    * 异常处理理论上有两种基本模型：
        * 终止模型：将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。
        * 恢复模型：异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。如果Java实现类似恢复的行为，那么在遇到错误时就不能抛出异常，而是调用方法来修正该错误。或者，在try块放在while循环里，这样就不断地进入try块，直到得到满意的结果。

* 不过恢复模型并不是很实用，主要是因为可能它导致的耦合，增加了代码编写和维护的困难。

####4.创建自定义异常
* 可以自定义异常类来表示程序中可能会遇到的特定问题。

* 默认构造器（不写构造器）或者自己定义构造器（可以接收参数）（可以通过super()调用基类构造器）
* P252

* 在异常处理程序中，可以调用在Throwable类声明的（Exception即从此类继承）的printStackTrace()方法，它将打印“”从方法调用处直到异常抛出处“的方法调用序列。
    * e.printStackTrace(); // 输出到标准错误流
    * e.printStackTrace(System.out); // 被发送到了System.out，并自动地被捕获和显示在输出中

* 异常与记录日志：
    * 使用java.util.logging工具将输出记录到日志中。

* P253

* 对于异常来说，getMessage()方法有点类似于toString()方法。

####5.异常说明
* Java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员。这是种优雅的做法，它使得调用者能够确切知道写什么样的代码可以捕获所有潜在的的异常。

* Java提供了相应的语法（并强制使用这个语法），使你能以礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员就可以进行相应的处理。
* 这就是异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后。使用关键字throws，后面接一个所有潜在异常类型的列表：
    * void f() throws TooBig, TooSmall, DivZero { // ...}

* 代码必须与一异常说明保持一致，如果方法里的代码产生了异常却没有进行处理，编译器会发现这个问题并提醒你：要么处理这个异常，要么就在异常说明中表明此方法将产生异常。

* 可以声明方法抛出异常，但实际上却不抛出，编译器相信了这个声明，并强制此方法的用户像真的抛出异常那样使用占个方法。这样做的好处是为异常先占个位子，，以后就可以抛出这种异常而不用修改已有的代码。
* 在定义抽象基类和接口时这种能力很重要，这样派生类或接口实现就能够抛出这些预先声明的异常。
* 这种在编译时被强制检查的异常称为“被检查的异常”。


####6.捕获所有异常
* 可以只写一个异常处理程序来捕获所有类型的异常，通过捕获异常类型的基类Exception，就可以做到这一点（事实上还有其他的基类，但Exception是同编程活动相关的基类）
    ```
    catch(Exception e) {
        // ...
    }
    这将捕获所有异常，所以最好把它放在处理程序列表的末尾，以防它抢在其他处理程序之前把异常捕获了。

    ```
    
* 可以调用Exception从基类Throwable继承的方法：
    ```
    String getMessage();
    String getLocalizedMessage(); // 本地语言表示的详细信息
    String toString();
    void printStackTrace();
    void printStackTrace(PrintStream);
    void printStackTrace(java.io.PrintWriter);
    
    Throwable fillInStackTrace()
    用于在Throwable对象的内部记录栈帧的当前状态，这在程序重新抛出错误或异常时很有用。

    ```
    
* 栈轨迹：
    * printStackTrace()方法所提供的信息可以通过getStackTrace()方法来直接访问，这个方法将返回一个由栈轨迹中的而元素所构成的数组。
    * 其中每一个元素都表示栈中的一帧，元素0是栈顶元素，并且是调用序列中的最后一个方法调用（这个Throwable被创建和抛出之处）
    * 数组的最后一个元素是调用序列中的第一个方法调用。
    * P258

* 重新抛出异常：
    * 如果希望把刚捕获的异常重新抛出，尤其是在使用Exception捕获所有异常的时候，既然已经得到了对当前异常对象的引用，直接把它重新抛出即可：
        ```
        try {
            ...
        } catch(Exception e) {
            ...
            throw e;
        }
        
        ```

    * 重抛异常会把异常抛给上一级环境中的异常处理程序，同一个try块的后续catch子句将被忽略。

    * 如果只是把当前异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。
    * 想要更新这个信息，可以调用fillInStackTrace()方法，它将返回一个Throwable对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的。
    * P258

        ```
        try {
            ...
        } catch(Exception e) {
            ...
            throw (Exception) e.fillInStackTrace();
        }
        ```

    * 有可能在捕获异常之后抛出另一种异常，这样做的话，得到的效果类似于使用fillInStackTrace()，有关原来异常发生点的信息会丢失，剩下的是与新的抛出点有关的信息。

    * 永远不必为清理前一个异常对象而担心，或者说为异常对象的清理而担心，它们都是用new在堆上创建的对象，所以垃圾回收器会自动把它们清理掉。


* 异常链：
    * 常常会想要在一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这称为“异常链”。
    * JDK1.4之后Throwable的子类在构造器中都可以接受一个cause（因由）对象作为参数。这个cause就用来表示原始异常。
    * 这样通过把原始异常传递给新的异常，使得即便在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。

* 有趣的是，在Throwable的子类中，只有三种基本的异常类提供了带cause参数的构造器。
* 它们是Error（用于Java虚拟机报告系统错误）、Exception以及RuntimeException（它其实也继承了Exception呢）。
* 如果要把其他类型的异常链接起来，应该使用initCause()方法而不是构造器。（@Todo 为什么呢？）
* P260

####7.Java标准异常

* Throwable这个Java类被用来表示任何可以作为异常被抛出的类。
* Throwable可以访问两种类型（指从Throwable继承而得到的类型）：
* Error用来表示编译时和系统错误（出特殊情况外，一般不用你关心）；
* Exception是可以被抛出的基本类型，在Java类库、用户方法以及运行时故障中都可能抛出Exception型异常。

* 异常的基本概念是用名称代表发生的问题，并且异常的名称应该可以望文知意。

* RuntimeException：
    * 属于运行时异常的类型有很多，它们会自动被Java虚拟机抛出，这些异常都是从RuntimeException类继承而来，所以既体现了继承的优点，使用起来也很方便。
    * 这构成了一组具有相同特征和行为的异常类型。
    * 它们被称为“不受检查异常”，不需要在异常说明中声明方法将抛出相关运行时异常。
    * 这种异常属于错误，将自动捕获，就不用你亲自动手了。尽管不用捕获，但还是可以在代码中抛出RuntimeException类型的异常。

* 如果不捕获这类异常会发生什么呢？
    * P264
    * 如果RuntimeException没有被捕获而直达main()，那么在程序退出前将调用异常的printStackTrace()方法。

* 务必记住：只能在代码中忽略RuntimeException（及其子类）类型的异常，其它类型异常的处理都是由编译器强制实施的。究其原因，RuntimeException代表的是编程错误：
    * （1、无法预料的错误。比如从你控制范围之外传递进来的null引用；
    * （2、作为程序员，应该在代码进行检查的错误。（比如对于ArrayIndexOutOfBoundsException，就得注意以下数组的大小了。）在一个地方发生的异常，常常会在另一个地方导致错误。

####8.使用finally进行清理
* 对于一些代码，可能会希望无论try块中的异常是否抛出，它们都能得到执行。
* 这通常适用于内存回收之外的情况（因为回收由垃圾回收器完成）。
* 为了达到这个效果，可以在异常处理程序后面加上finally子句。

* finally用来做什么：
    * 对于没有垃圾回收和析构函数自动调用机制的语言来说，finally非常重要，它能使程序员保证；无论try块发生了什么，内存总能得到释放。
    * 对于Java来说，当要把除内存之外的资源恢复到它们的初始状态时，就要用到finally子句。
    * 这种需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关……
    * P266

* 当涉及break和continue语句的时候，finally子句也会得到执行。请注意，如果把finally子句和带标签的break及continue配合使用，在Java里就没有必要使用goto语句了。

* 在return中使用finally：
    * 因为在finally子句总是会执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的的清理工作仍旧会执行。

* 遗憾：异常丢失
    * 用某些特殊的方式使用finally子句，就会发生这种情况：
    * P268

    * 另外如果在finally子句返回：
        ```
        try {
            throw new RuntimeException();
        } finally [
            return;
        }
        \```

    * 即便抛出了异常，也不会产生任何输出！

####9.异常的限制
* 当覆盖方法时，只能抛出在基类方法的异常说明列出的那些异常。这个限制很有用，因为这意味着，当基类使用的代码应用到其派生类对象的时候，一样能够工作（当然这个面向对象的基本概念），异常也不例外。
* P269

* 如果类继承某个基类然后实现了某个接口，存在同名方法，比如event()，该方法基类和接口的异常说明不一致，那么派生类如果重载event()方法，则只能声明两者交集的异常。（才能保证通过基类或接口调用方法时，判断是否捕获正确的异常。）

* 另外派生类覆盖的方法的异常说明的异常可以是基类异常说明异常的子类。

* 通过强制派生类遵守基类方法的异常说明，对象的可替换性得到了保证。

* 异常限制对构造器不起作用，但派生类构造器的异常说明必须包含基类构造器的异常说明。

* 派生类构造器不能捕获基类构造器抛出的异常。

* 使用派生类时，编译器会强制捕获这个类所抛出的异常，但如果将他向上转型成基类，那么编译器就会（正确地）要求你捕获基类的异常。

* 在继承中，基类的方法必须出现在派生类里，换句话说，在继承和覆盖的过程中，某个特定方法的“异常说明的接口”不是变大了而是变小了——这恰好和类接口在继承时的情形相反。

####10.构造器
* “如果异常发生了，所有东西都能被正确清理吗？”
* 涉及构造器时，问题就出现了，构造器会把对象设置成安全的初始状态，但还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理。
* 如果构造器内抛出了异常，这些清理行为也许就不能正常工作了。
* P272

* 通常的清理惯用用法不管构造器是否抛出异常都应该运用，其基本规则是：在创建要清理的对象之后，立即进入一个try-finally语句块。
* P274

####11.异常匹配
* 抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。
* 查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序（就像Exception可以catch所有异常）。
* P275

####12.其他可选方式
* 异常处理的一个重要原则是“只有在你知道如何处理的情况下才捕获异常”。
* 实际上，异常处理的一个重要目标就是“把错误处理的代码同错误发生的地点相分离”。

* “被检查的异常”使这个问题变得有些复杂，因为它们强制你在可能还没准备好处理错误的时候被迫加上catch子句，这就导致了“吞食则有害”的问题。

* “被检查的异常”及其并发症，以及采用什么方法解决这些问题。 

* 评价被检查异常：要写一些通常不用写的、“多出来的”代码，但“多出来的”带米绝不能太多！

* 异常说明的两种意思：
    * 1、我的代码会产生这种异常，这由你来处理（最里层的方法甩锅）
    * 2、我的代码忽略了这些异常，这由你来处理（最里层之外的方法不想处理继续甩锅）

* 如果发现有些“被检查的异常”挡住了路，尤其是发现你不得不去对付那些不知道该如何处理的异常，还是有些办法的：
* 把异常传递给控制台（终极甩锅）
    * P279

* 把“被检查的异常”转换为“不检查的异常”（默默接下了锅，只要锅炸了，就往外抛出一个运行时异常并说了一句“MMP”）
    * 考虑到“我不知道该怎样处理这个异常，但是我也不想把它‘吞’了”，可以把“被检查的异常”包装进RuntimeException里面：throw new RuntimeException(e);
    * 这种技巧给了你一种选择，你可以不写try-catch子句和/或异常说明，直接忽略异常，让它沿着调用栈往上“冒泡”，同时，还可以用getCause()捕获并处理特定的异常。
    * P280

####13.异常使用指南
* 应该在下列情况下使用异常：
    * （1、在恰当的级别处理问题（在知道该如何处理的情况才捕获异常）
    * （2、解决问题并且重新调用产生异常的方法
    * （3、进行少许修补，然后绕过异常发生的地方继续执行
    * （4、用别的数据进行计算，以代替方法预计会返回的值
    * （5、把当前运行环境下能做的事情尽量做完，然后把相同的异常重新抛到更高层
    * （6、把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层
    * （7、终止程序
    * （8、进行简化（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人）
    * （9、让类库和程序更安全（这既是在为调试做短期投资，也是在为程序的健壮成长做长期投资。）
    * （9、让类库和程序更安全（这既是在为调试做短期投资，也是在为程序的健壮成长做长期投资。）


###13、字符串
字符串操作是计算机程序设计中最常见的行为

####1.不可变String
* String对象是不可变的。查看JDK文档你就会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象则丝毫不动。

* 每当把String对象作为参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过。

* 对于一个方法而言，参数是为该方法提供信息的，而不是想让该方法改变自己的！

####2.重载“+”与StringBuilder
* 可以给一个String对象加任意多的别名，因为String对象具有只能特性，所以指向它的任何引用都不可能改变它的值。因此，也就不会对其他的引用有什么影响。

* 不可变性会带来一定的效率问题。
* 为String对象重载的“+”操作符就是一个例子。重载的意思是，一个操作符在应用于特定的类时，被赋予了特殊的意义（用于String的“+”和“+=”是Java中仅有的两个重载过的操作符，而Java并不允许程序员重载任何操作符）

* javap -c 类名 // 生成字节码（需在该类的class下执行）

* 通过查看机器码我们可以发现：在进行String的“+”操作时，编译器自动引入了StringBuilder类。
* 但如果是在循环中进行String的“+”或“+=”，那么每循环一次，就会创建一个新的StringBuilder对象。所以最好自己创建一个StringBuilder对象。

* StringBuilder提供了丰富而全面的方法，包括insert()、replace()、substring()设置reverse()、delete()等，常见的的还是append()和toString()。

* StringBuilder是Java SE5引入的，在这之前Java用的是StringBuffer，它是线程安全的，因此开销会大些。

####3.无意识的递归
* 如果想要打印对象的内存地址，应该调用Object.toString()方法，这才是负责此任务的方法。所以不应该使用this，应该调用super.toString()方法。
    ```
    public void toString() {
        return "Xx address:" + super.toString() + "\n";
        // return "Xx address:" + this + "\n"; // 使用this会发生递归，因为this前面是“+”，编译器试图将this转成字符串，对象转字符串自然是调用toString()方法了，然后就发生了递归调用，得到异常。
    }
    ```
    
####4.String上的操作
```
length()
charAt()
contains()
regionMatcher() // 参数是该String的索引偏移量，另一个String及其索引偏移量，要比较的长度。返回boolean结果，以表明所比较区域是否相等
startsWith()
endsWith()
indexOf()、lastIndexOf()
substring()
concat() // 参数是要要连接的String，返回一个新的String对象，内容为原始String连接上参数String
trim()
intern() // 为每个唯一的字符序列生成一个且仅生成一个String引用
....

```

当需要改变字符串的内容时，String类的方法都会返回一个新的String对象。同时，如果内容没有发生改变，String的方法只是返回指向原对象的引用而已。这可以节约存储空间以及避免额外的开销。

####5.格式化输出
```
C语言的printf()：
printf("Row 1: [%d %f]\n", x, y)

System.out.format()：
format()方法可以用于PrintStream或PrintWriter对象，其中也包括System.out对象（PrintStream）。
format()方法模仿自C语言的printf()，当然也有System.out.printf()。
int x = 5;
double y = 5.332542;
System.out.println("Row 1: [" + x + " " + y + "]");
System.out.format("Row 1: [%d %f]\n", x, y);
System.out.printf("Row 1: [%d %f]\n", x, y);
```

* （1、Formatter类：
    * 在Java中，所有新的格式化功能都由java.util.Formatter类处理，可以将Formatter看座一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。
    * P290
        ```
        ...
        private Formatter f;
        public void move(int x, int y) {
            f.format("%s The Turtle is at (%d,%d)\n", name, x, y);
        }
        ...
        
        ```

* （2、格式化说明符：
    * %[argument_index$][flags][width][,precision]conversion
    * P291


* （3、Formatter转换：
    ```
    d   整数型（十进制）
    e   Unicode字符
    b   Boolean值
    s   String
    f   浮点数（十进制）
    e   浮点数（科学计数）
    x   整数（十六进制）
    h   散列码（十六进制）
    %   字符“%”
    ```

    * P292

    * 将b用于非布尔类型的对象是要格外小心，因为只要对象部位null，转换的寄过永远都是true！


* （4、String.format()：
    * Java SE5也参考了C中的sprintf()方法，以生成格式化的String对象。String.format()是一个static方法，它接受与Formatter.format()方法一样的参数，但返回一个String对象。

    * 当你只需使用format()方法一次时，String.format()用起来很方便。
    * 其实在String.format()内部，它也是创建一个Formatter对象。

    * P294

####6.正则表达式
* 正则表达式是一种强大而灵活的文本处理工具。使用正则表达式，我们能够以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索，一旦找到了匹配这些模式的部分，你就能够随心所欲地对它们进行处理。
* 正则表达式提供了一种完全通用的方式，能够解决各种字符串处理相关的问题：匹配、选择、编辑以及验证。

* （1、基础：
    * 一般来说，正则表达式就是以某种方式来描述字符串，因此你可以说“如果一个字符串含有这些东西，那么它就是我正在找的东西。”
    * 例如：
        * 可能以负号开头：-?
        * 描述一个整数：\d

    * 在其他语言中，\\表示“我想要在正则表达式中插入一个普通的（字面上的）反斜线，请不要给它任何特殊意义。”
    * 在Java中，对反斜线\的有着不同处理，比如\\的意思是“我要插入一个正则表达式的反斜线，所以其后的字符具有特殊意义。”
    * 例如，表示一位数字：\\d；插入一个普通的反斜线，则应该这样：\\\\。
    * 不过换行和制表符之类的额东西只需使用单反斜线：\n\t。

    * 要表示“一个或多个之前的表达式”，应该使用+。所以，如果要表示“可能有一个负号，后面跟着一位或多位数字”，可以这样：-?\\d+

    * 应用正则表达式最简单的途径，就是利用String类内建的功能，例如，你可以检查一个String是否匹配如上所述的正则表达式：
        ```
        System.out.println("-1234".matches("-?\\d+")); // true 表示可能有减号开头的1个数字
        System.out.println("+911".matches("-?\\d+")); // false 表示可能有减号开头的多个数字
        System.out.println("+911".matches("(-|\\+)?\\d+")); // true 表示可能有减号或加号开头的一个或多个数字

        ```
    * 可能以一个加号或减号开头（可以有-或+，或者二者都没有，因为后面跟着?修饰符）：(-|//+)?
    * 字符+在正则表达式中有特殊的意义，所以必须使用\\将其转义，使之成为表达式中的一个普通字符。

    * String类还自带了一个非常有用的正则表达式工具——split()方法，其功能是“将字符串从正则表达式匹配的地方切开”
    * P296

    * \\W：非单词字符（如果是W小写，\w，则表示一个单词字符）

    * n\\W+：表示字母n后面跟着一个或多个非单词字符

    * String.split()还有一个重载版本，它允许你限制字符串分割的次数。

    * String类自带的最后一个正则表达式工具是“替换”，你可以只替换正则表达式第一个匹配的字串，或是替换所有匹配的地方。
        ```
        replaceFirst、replaceAll
        System.out.println(("fxxxx,dfdfdx..dfdsfd").replaceFirst("f\\w+", "666")); // 匹配字符f开头，后面跟着一个或多个字母
        System.out.println(("fxxxx,dfdfdx..dfdsfd").replaceAll("f\\w+", "666"));
        System.out.println(("fxxxx,dfdfdx..dfdsfd").replaceAll("fxxxx|dfdfdx|dfdsfd", "666")); // 匹配三个单词中的任意一个

        ```

* （2、创建正则表达式：
    * 正则表达式的完整构造子列表，参考JDK文档java.util.regex包中的Pattern类。

    * P298常用表达式列表

* （3、量词：
    * 量词描述了一个模式吸收输入文本的方式：
    * 贪婪型：
        * 为所有可能的模式发现尽可能多的匹配。假设我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么就会继续往下匹配。

    * 勉强型（?）：
        * 这个量词匹配满足模式所需的最少字符数，因此也称作懒惰的、最少匹配的、非贪婪的、或不贪婪的。

    * 占有型（+）：
        * 目前，只是在Java语言中才可用，并且也最高级。当正则表达式被应用于字符串时，它会产生相当对的状态，以便匹配失败时可以回溯。而“占有的”量词并不保存这些中间状态，因此 它们可以防止回溯。
        * 它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更有效。

        * P299

    * 表达式X通常必须要用圆括号括起来，以便它能够按照我们期望的效果去执行，例如
    * abc+：匹配ab，后面跟随1个或多个c；
    * (abc)+：匹配1个或多个完整的abc字符串
        ```
        CharSequence：
        接口CharSequence从CharBuffer、String、StringBuffer、StringBuilder类之中抽象除了字符序列的一般化定义：
        interface CharSequence {
            charAt(int i);
            length();
            subSequence(int start, int end);
            toString();
        }
        ```
    * 因此，这些类都实现了该接口。多数正则表达式操作都接受CharSequence类型的参数。

* （4、Pattern和Matcher：
```
...
String str = "abcabcacbacefacb";
Pattern p = Pattern.compile("(abc)+");
Matcher m = p.matcher(str);
while(m.find()) {
    System.out.println("Match " + m.group() + "at position " + m.start() + "-" + (m.end() - 1));
}

Pattern提供了static方法：
static boolean matches(String regex, CharSequence input)：用于检查regex是否匹配整个CharSequence类型的input参数。

Matcher对象，以下方法能够判断各种不同类型的匹配是否成功：
boolean matches();
boolean lookingAt();
boolean find();
boolean find(int start);

其中matches()方法用来判断整个输入字符串是否匹配正则表达式模式，而lookingAt()则用来判断字符串（不必是整个字符串）的始部分是否能够匹配模式。

```

* find()：
    * Matcher.find()方法可用来在CharSequence中查找多个匹配。
    * 方法可以带上一个整数作为参数，表示字符串中字符的位置，并以其作为搜索的起点。

    * P301

* 组（Groups）：
    * 组是用括号划分的正则表达式，可以根据组的编号来引用某个组。组号为0表示整个表达式，组号为1表示被第一对括号括起的组，以此类推。
    * A(B(C))D
    * 三个组：组0是ABCD，组1是BC，组2是C。

    * Matcher方法提供一系列的方法，用以获取与组相关的信息：
    * int gropCount()返回该匹配器的模式中的分组数目（第0组不包括在内）；
    * String group()返回前一次匹配操作（例如find()）的第0组（整个匹配）；
    * String group(int i)返回在前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组号没有匹配输入字符串的任何部分，则将会返回null；
    * int start(int group)返回在前一次匹配操作中寻找到的组的起始索引；
    * int end(int group)返回在前一次匹配操作中寻找到的组的最后一个字符串索引加1的值。

    * P302

* start()与end()：
    * 在匹配操作成功之后，start()返回先前匹配的起始位置的索引，而end()返回所匹配的最后字符的索引加1的值。
    * 匹配操作失败之后（或先于一个正在进行的匹配操作去尝试）调用start()或end()将会产生IllegalStateException。

    * P303

    * find()可以在输入的任意位置定位正则表达式，而lookingAt()和matches()只有在正则表达式与输入的最开始处就开始匹配时才会成功。
    * matches()只有在整个输入都匹配正则表达式时才会成功，而lookingAt()只要输入的第一部分匹配就会成功。


* Pattern标记：
    * Pattern类的compile()方法还有另一个版本，它接受一个标记参数，以调整匹配的行为：
    * Pattern Pattern.compile(String regex, int flag)

    * 可以通过“或”（|）操作符组合多个标记的功能。

    * P304


* （5、split()：
    * split()方法将输入的字符串断开成字符串对象数组，断开边界由下列正则表达式确定：
        * String[] split(CharSequence input);
        * Stringp[ split(CharSequence input, int limit); // 可以限制将输入分割字符串的数量

    * P305


* （6、替换操作：
    * 正则表达式特别便于替换文本，它提供了许多方法：
        * replaceFirst(String replacement)：以参数字符串replacement替换掉第一个匹配成功的部分；
        * replaceAll(String replacement)：以参数字符串replacement替换所有匹配成功的部分；
        * appendReplacement(StringBuffer sbuf, String replacement)执行渐进式的替换，而不是像replaceFirst()和replaceAll()那样只替换第一个匹配或全部匹配。
            * 这是个非常重要的方法，它允许你调用其他方法来生成或处理replacement（replaceFirst()和replaceAll()则只能使用一个固定的字符串），使你能够以编程的方式将目标分割成组，从而具备更强大的替换功能。
        * appendTail(StringBuffer sbuf)，执行了一次或多次appendReplacement()之后，调用此方法可以将输入字符串余下的部分复制到sbuf中。
            * P306
         * appendReplacement()方法还允许你通过$g直接找到匹配的某个组，这里的g就是组号，然而，它只能应付一些简单的处理。

* （7、reset()：
    * 通过reset()方法，可以将现有的Matcher对象应用于一个新的字符序列：
    * P307
    * 使用不带reset()方法，可以将Matcher对象重新设置到当前字符序列的其实位置。

* （8、正则表达式与Java I/O：
    * 如何应用正则表达式子在一个文件中进行搜索匹配操作。
    * P308

####7.扫描输入
* 到目前为止，从文件或标准输入读取数据还是一件相当痛苦的事，一般的解决之道就是读入一行文本，对其进行分词，然后使用Integer、Double等类的各种解析方法来解析数据：
* P309

* （1、Java SE5新增的Scanner方法，它可以大大减轻扫描输入的工作负担：
    * P310

* （2、Scanner定界符：
    * 在默认情况下，Scanner根据空白字符对输入进行分词，但是你可以用正则表达式指定自己所需的定界符：
    * P311

    * 用useDelimiter()来设置定界符，调用delimiter()方法可以返回当前正在作为定界符使用的Pattern对象。

* （3、使用正则表达式扫描：
    * P311

####8.StringTokenizer
* 在Java引入正则表达式（J2SE1.4）和Scanner类（Java SE5）之前，分割字符串的唯一方法是使用StringTokenizer来分词。
    * 基本上可以废弃不用了！


###16、数组

####1.数组为什么特殊

* 数组与其他种类的容器之间的区别有是三方面：效率、类型和保存基本类型的能力。

* 在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但为这种快速付出的代价是数组对象大小被固定。

* 泛型出来之后，数组仅存的优点就是效率。


####2.数组是第一级对象

* 无论使用那种类型的数组，数组标识符其实只是一个引用，指向在堆中创建的一个真实对象，这个（数组）对象用以保存指向其他对象的引用。

* 对象数组和基本类型数组在使用上几乎是相同的，唯一的区别就是对象数组保存的是引用，基本类型数组直接保存基本类型的值。
    ```
    int[] arrayA = new int[]{1, 2, 3, 4};
    int[] arrayB = arrayA;
    arrayB[0] = 0; // arrayA、arrayB指向堆中的同一数组对象，对arrayB中元素操作，arrayA同样改变（因为指向同一对象啊）
    ```

####3.返回一个数组
* 假设你要写一个方法，而且希望它返回不止一个值，而是一个数组。对于C和C++来说有点困难，它们不能返回一个数组，而只能返回指向数组的指针，这会造成一些问题，因为它使得控制数组的生命周期变得困难，并且容易造成内存泄露。
* 在Java中，你只是直接“返回一个数组”，而无需担心要为数组负责——只要你需要它，它就会一直存在，当你使用完后，垃圾回收器会清理它。

####4.多维数组
```
int[][] arrayMd = {{1, 2, 3}, {4, 5, 6} };
System.out.println("arrayMd:" + Arrays.toString(arrayMd));
System.out.println("arrayMd:" + Arrays.deepToString(arrayMd)); // 可以将多维数组转换为多个String

int[][][] arrayMd_ = new int[2][2][4];
System.out.println("arrayMd:" + Arrays.deepToString(arrayMd_));

```

* 粗糙数组：数组中构成矩阵的每个向量都可以具有任意的长度
```
Integer[][] arrayI = new Integer[3][];
for (int i = 0; i < arrayI.length; i++) {
    arrayI[i] = new Integer[3]; // 创建第二层数组对象
    for (int j = 0; j < arrayI[i].length; j++) {
        arrayI[i][j] = i * j; // 给第二层数组对象赋值
     }
}
System.out.println("arrayI:" + Arrays.deepToString(arrayI));

Double[][][] arrayD = {{{1.1, 1.2, }, {3.3, 4.4}}, {{5.5, 6.6}, {7.7, 8.8}}, }; // 多出一些,其实没问题的
System.out.println("arrayDP:" + Arrays.deepToString(arrayD));

```

####5.数组与泛型
* 通常，数组与泛型不能很好地结合。
* Peel<Banana>[] peels = new Peel<Banana>[10]; // 编译错误
* 擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。

* 但是，你可以参数化数组本身的类型：
    * P440

* 不能创建泛型数组这一说法并不十分准确。编译器确实不让你实例化泛型数组，但是，它允许你创建对这个数组的引用，例如：
    ```
    List<String>[] ls;
    这条语句可以顺利通过编译而不抱任何错误。而且，尽管你不能创建实际的持有泛型的数组对象，但是你可以创建非泛型的数组，然后将其转型：
    List<String>[] ls;
    List[] la = new List[10];
    ls = (List<String>[]) la; // "Unchecked" warning
    ls[0] = new ArrayList<String>();
    // ls[1] = new ArrayList<Integer>(); // 编译失败
    
    Object[] objects = ls;
    objects[1] = new ArrayList<Integer>(); // Compiles and runs without complaint.
    
    一旦拥有了List<String>[]的引用，你就会看到你将得到某些编译器检查。问题是数组是协变类型的，因此List<String>[]也是一个Object[]，并且你可以利用这一点：将ArrayList<Integer>赋值到你的数组中，而不会有任何编译器或运行时错误。

    ```

####6.创建测试数据

* Arrays.fill()：
    * 只能用同一个值填充各个位置，而针对对象而言，就是复制同一个引用进行填充，另外也可以指定填充区域。

* 数组生成器：
    * P443

####7.Arrays实用功能

* equals()：用于比较两个数组是否相等（deepEquals()用于多维数组）；
* fill()：用同一个值填充数组
* sort()：用于对数组排序
* binarySearch()：用于在已经排序的数组中查找元素
* toString()：产生数组的String表示（deepToString()用于多维数组）
* hashCode()：产生数组的散列码
* 这些方法对各种类型和Object类而重载过，此外，Arrays.asList()接受任意的序列或数组作为参数，并将其转变为List容器。


* （1、复制数组：
    * Java标准类库提供有static方法System.arraycopy()，用它复制数组比用for循环复制要快很多。
    * System.arraycopy()对很多类型做了重载。
    * P450

    * arraycopy()需要的参数有：源数组，表示从源数组中的什么位置开始复制的偏移量，表示从目标数组的什么位置开始复制的偏移量，以及需要复制的元素个数。
    * 基本类型数组与对象数组都可以复制，如果复制对象数组，那么只是复制了对象的引用——而不是对象本身的拷贝。这被称为“浅复制”。
    * arraycopy()不会执行自动包装和自动拆包，两个数组必须具有相同的确切类型。

* （2、数组的比较：
    * Arrays类提供重载后的equals()方法，用于比较整个数组。数组相等的条件是元素个数必须相等，并且对应位置的元素也相等，这可以通过对每一个元素使用equals()（基于内容的）作比较判断（对于基本类型，需要使用基本类型的包装器类的equals()方法，例如int类型使用Integer.equals()作比较）
    * 另外也不会执行自动包装和自动拆包。

* （3、数组元素的比较：
    * 排序必须根据对象的实际类型执行比较操作，一种自然的解决方案是为每种不同的类型各编写一个不同的排序方法，但是这样的代码难以被新的类型所复用。
    * 程序设计的基本目标是“将保持不变的事物与会发生改变的事物相分离”，这里，不变的是通用的排序算法，变化的是各种对象相互比较的方式。
    * 因此，不是将进行比较的代码编写成功不同的子程序，而是使用“策略设计模式”。
    * 通过使用策略，可以将“会发生改变的代码”封装成单独的类中（策略对象），你可以将策略对象传递给总是相同的代码，这些代码将使用策略来完成其算法。

    * Java有两种方法来提供比较功能，第一种是实现Comparable接口，使用你的类具有“天生”的比较能力，重写compareTo()方法，此方法接收另一个Object为参数，如果当前对象小于参数则返回负值，相等则返回零，大于则返回正值。
    * P452

    * 第二种方式是可以创建一个实现了Comparator接口的单独的类，这是策略模式的一个应用实例，这个类有compare()和equals()两个方法。
    * P454

* （4、数组排序：
    * 使用内置的排序方法，就可以对任意的基本类型数组排序；也可以对任意的对象数组进行排序只要该对象实现了Comparable接口或具有相关联的Comparator。
    * 关于String对象数组排序的示例：
    * P455

    * Java标准类库中的排序算法针对正排序的特殊类型进行了优化——针对基本类型设计的“快速排序”，以及针对对象设计的“稳定归并排序”。所以无须担心排序的性能，除非你可以证明排序部分的确是程序效率的瓶颈。

* （5、在已排序的数组中查找：
    * 如果数组已经排好序了，就可以使用Arrays.binarySearch()执行快速查找。如果要对未排序的数组使用binarySearch()，那么将会产生不可预料的结果。
    * P455

    * 如果找到了目标，Array.binarySearch()产生的返回值等于或大于0。否则，它产生负返回值，表示若要保持数组的排序状态此目标所应该插入的位置，计算方式：
    * -(插入点) - 1
    * “插入点”是指，第一个大于查找对象的元素在数组的位置，如果数组中所有元素都小于要查找的元素，则“插入点”就等于数组长度。

    * 如果数组中包含了重复的元素，则无法保证找到的是这些副本中的哪一个。

    * 如果需要对没有重复元素的数组排序，可以使用TreeSet（保持排序顺序）或者LinkedHashSet（保持插入顺序）。这些类会自动处理所有的细节。除非它们成为程序性能的瓶颈，否则不需要自己维护数组。

    * 如果使用Comparator排序了某个对象数组（基本类型数组无法使用Comparator排序），在使用binarySearch()时必须使用同样的Comparator（binarySearch重载方法的第三个参数）。

* 总结：
    * “优选容器而不是数组”，只有在已证明性能成为问题（并且切换到数组对性能提高有所帮助）时，你才应该将程序重构使用数组。

###15、泛型
Java泛型的优点和局限

####1.与C++的比较
原因有二：
* 一，了解C++模板的某些方面，有助于你理解泛型的基础；另外可以了解到Java泛型的局限在哪里。（只有知道了某个技术不能做到什么，你才能更好地做到所能做的！）
* 二、在Java社区中，人们普遍对C++模板有一种误解可能会误导你，令你子啊理解泛型的意图时产生偏差。


####2.简单泛型
通常而言，我们只会使容器来存储一种类型的对象。泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。

类型参数T：@Todo

* （1、一个元组类库
    * 元组：将一组对象直接打包存储于其中的一个单一对象，这个容器允许你读取其中的元素，但是不允许你向其中存放新的对象。（也叫数据传送对象，或信使）
    * P354

* （2、一个堆栈类
    * LinkedStack<T>
    * P3576

* （3、RandomList
    * RandomList<T>
    * P357

####3.泛型接口
* 泛型也可以应用于接口。例如生成器（generator）
    ```
    public interface Generator<T> {
        T next();
    }
    ```

* CoffeeGenerator.java
    * P358

* Fibonacci.java & IterableFibonacci.java
    * P360

* Java泛型的局限性之一：基本类型无法作为类型参数，不过Java SE5具备了自动打包和自动拆包的功能。

####4.泛型方法
可以在类中包含参数化方法，而这个方法所在的类中可以是泛型类，也可以不是泛型类。

无论何时，只要你能做到，你就应该尽量使用泛型方法。

对于一个static方法而言，无法访问泛型类的类型参数，所以，如果static方法需要使用泛型能力，就必须使其成为泛型方法。

要定义泛型方法，只需要将泛型参数列表置于返回值之前，如：
```
public <T> void f(T x) {
    System.out.println(x.getClass.getName());
}
```

* （1、杠杆利用类型参数推断
    * P362

    * 类型推断只对赋值操作有效，其他时候并不起作用。

    * 在泛型方法中，可以显式地指明类型，不过这种语法很少使用。要显式地指明类型，必须在点操作符与方法名之间插入尖括号。
    ```
    f(New.<Person, List<Pet>>map());
    ```

* （2、可变参数与泛型方法
    * 泛型方法与可变参数列表能够很好地共存：
    ```
    public static <T> List<T> makeList(T... args) {
        // ...
    }
    ```

* （3、用于Generator的泛型方法
    * 利用生成器，我们可以很方便地填充一个Collection，而泛型化这种操作是更具实际意义的：
    * P364

* （4、一个通用的Generator
    * P364

* （5、简化元组的使用
    * 类型参数推断，再加上static方法，可以重新编写之前的元组工具，使之称为更通用的工具类库。
    * P366

* （6、一个Set实用工具
    * P367

####5.匿名内部类
泛型还可以应用于内部类以及匿名内部类。
P369

####6.构造复杂模型
泛型的一个重要好处就是能够简单而安全地创建复杂的模型。
P371

####7.擦除的神秘之处
在泛型代码内部，无法获得任何有关泛型参数类型的信息。

Java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了。

* （1、C++的方式
    * P374

    * 边界<T extends HasF>声明T必须具有类型HasF或者从HasF导出的类型，如果情况确实如此，那么就可以安全的从T对象上调用HasF对象的方法了。

    * 只有当你希望使用的类型参数比某个具体类型（以及它的所有子类型）更加“泛化”时——也就是说，当你希望代码能够跨多各类工作时，使用泛型才有所帮助。

* （2、迁移兼容性：
    * 泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。
    * 例如，诸如List<T>这样的类型注解将被擦除为List，而普通的类型变量在未指定边界的情况下将被擦除为Object。

    * 擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”。


* （3、擦除的问题：
    * 擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破话现有类库的情况下，将泛型融入Java语言。

    * 擦除的代价很显著，泛型不能用于显式地引用运行时类型的操作之中，例如转型、instanceof操作和new表达式。因为所有关于参数的类型信息都丢失了。
    * 无论如何，当你编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。

    * 另外，擦除和迁移兼容性意味着，使用泛型并不是强制的

* （4、边界处的动作：
    * 正是因为有了擦除，泛型最令人困惑的方面源于这样一个事实，即可以表示没有任何意义的事物：

    * 因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。

    * 泛型中的所有动作都发生在边界处——对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。

####8.擦除的补偿

* （1、创建类型实例
    * P381

    * 显式的工厂，并将限制其类型（因为考虑到Integer之类的对象有些是没有默认的构造器的，无法通过class的newInstance方法来实例化对象）

    ```
    interface Factory<T> {
        T create();
    }
    
    class IntegerFactory implements Factory<Integer> {
        public Integer create() {
                return new Integer(0);
        }
    }
    
    class Widget {
    
        // 内部工厂类
        public static class Factory implements Factory<Widget> {
            public Widget create() {
                return new widget();
            }
        }
    }
    
    // 使用
    (new IntegerFactory()).create();
    (new Widget.Factory()).create();
    
    ...
    
    或者使用模板方法设计模式。
    
    abstract class GenericWithCreate<T> {
        final T element;
        GenericWithCreate() {
            element = create();
        }
        abstract T create();
    }
    
    class X {}
    
    class Creator extends GenericWithCreateL<X> {
        X create() {
            return new X();
        }
        void f() {
            System.out.println(element.getClass().getSimpleName());
        }
    }
    
    // main
    Creator c = new Creator();
    c.f();
    
    ```

* （2、泛型数组
    * P383

    * 成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型。
    ```
    static final int SIZE = 100;
    static Generic<Integer> gia;
    
    gia =  (Generic<Integer>[]) new Generic[SIZE]; // 编译成功，但是会得到有关这个转型的警告
    // gia = (Generic<Integer>[]) new Object[SIZE]; // 编译失败
    gia[0] = new Generic<Integer>();
    // gia[1] = new Object(); // 编译失败
    // gia[2] = new Generic<Double>(); // 编译失败
    
    因为有了擦除，数组的运行时类型就只能是Object[]。
    ```

    * P385

####9.边界
* 边界使得你可以在用于泛型的参数类型上设置限制条件，尽管这使得你可以强制规定泛型可以应用的类型，但是其潜在的一个更重要的效果是你可以按照自己的边界类型来调用方法。

* extends关键字：
    * P387

####10.通配符
* P390
* Apple的List不是Fruit的List，Apple的List将持有Apple和Apple的子类型，而Fruit的List将持有任何类型的Fruit，诚然这包括Apple在内，但是它不是一个Apple的List，它仍旧是Fruit的List。Apple的List在类型上不等价于Fruit的List，即使Apple是一种Fruit的类型。
* （水果篮子可以装苹果，但是水果篮子并不等于苹果篮子）本质问题是我们在谈论容器的类型，而不是容器持有的类型。
* 与数组不同，泛型没有内建的协变类型。

```
List<? extends Fruit> fList = new ArrayList<Apple>();
// 编译失败，add()的参数是“? edtends Fruit”，但编译器并不能了解这里需要Fruit的哪种具体子类型，因此它不会接受任何类型的Fruit。
// fList.add(new Apple());
// fList.add(new Fruit());
// fList.add(new Object());
fList.add(null); // OK
Fruit f = fList.get(0); // OK
```

* // ? super T：?表示T的超类，所以从?取到的值只能转为Object（向上，不可向下），但设置则可以是任意子类
* // ? extends T：?表示T的子类


* （1、编译器有多聪明
    * P391
    ```
    Apple apple = (Apple) fList.get(0); // OK
    // contains方法和indexOf方法可以传递Apple对象，因为方法参数是Object
    fList.contains(new Apple());
    fList.indexOf(new Apple());
    
    编译器只关注传递进来和要返回的对象类型，它不会分析代码，以查看是否执行了任何实际的写入和读取操作。

    ```

* （2、逆变
    * 超类型匹配符：可以声明通配符是由某个特定类的任何基类来界定的，指定<? super MyClass>，甚至或者使用参数类型：<? super T>
    * 你不能对泛型参数给出一个超类型边界；即不能声明<T super MyClass>！
    
    * P393

    ```
    static void writeTo(List<? super Apple> apples) {
        apples.add(new Apple());
        apples.add(new Jonathan());
        // apples.add(new Fruit()); // 编译失败
    }
    ```

    * super 和 extends的区别到底在哪里？ @TODO


* （3、无界通配符
    * 无界通配符<?>
    * P395

    * List实际上表示“持有任何Object类型的原生List”，而List<?>表示“具有某种特定类型的非原生List，只是我们不知道那种类型是什么”

    * 编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？
    * P396

    * 是否使用通配符，取决于是否想要从泛型参数返回类型确定的返回值，或者是否想要向泛型参数传递类型确定的参数。

    * @Todo 泛型参数是否需要确定的类型：
        ```
        <?>
        <T>
        <? extends T>
        <? super T>
        ```

* （4、捕获转换
    * 有一种特殊情况特别需要使用<?>而不是原生类型。
    * 捕获转换：如果向一个使用<?>的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。
    * P399

####11.问题
* （1、任何基本类型都不能作为类型参数
    * 使用基本类型的包装类，且Java SE5之后有自动装包机制。
    * 限制：自动转包机制不适用于数组


* （2、实现参数化接口
    * 一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。
    * 如：
        ```
        interface Payable<T> {}
    
        class Employee implement Payable<Employee> {}
        
        class Hourly extends Employee implements Payable<Hourly> {}
        
        Hourly不能编译，因为擦除会将Payable<Employee>和Payable<Hourly>简化为相同的类Payable。如果移除掉泛型参数，这段代码是可以编译的。

        ```

* （3、转型和警告
    * 使用带有泛型类型参数的转型或instanceof不会有任何效果。
    * P402


* （4、重载
    ```
    public class UseList<W, T> {
        void f(List<T> v) {}
        void f(List<W> w) {}
    }
    ```
    * 由于擦除的原因，重载方法将产生相同的类型签名。


（5、基类挟持了接口
P404

####12.自限定的类型
* 在Java泛型中，有一个好像是经常性出现的惯用法，它相当令人费解：
    ```
    class SelfBounded<T extends SelefBounded<T>> { // ...
    ```

* 它强调的是当extends关键字用于边界与用来创建子类明显是不同的。

    * （1、古怪的循环泛型
        * P405

        * “古怪的循环泛型”（CRG）的本质：基类用导出类替代其参数。

    * （2、自限定
        * P406
        * 自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
            ```
            class A extends SelefBounded<A> {}
            ```
        * 这会强制要求将正在定义的类当作参数传递给基类。
        * 自限定的意义：保证类型参数必须与正在被定义的类相同。
        * 自限定也可以用于泛型方法。

    * （3、参数协变
        * 自限定类型的价值在于它们可以产生协变参数类型——方法参数类型会随子类而变化。
        * P407

* 如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样。
* P409

####13.动态类型安全
* 因为可以向Java SE5之前的代码传递泛型容器，所以旧式代码仍旧有可能会破坏你的容器，Java SE5的java.util.Collections中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：
* 静态方法checkedCollection()、checkedList()、checkedMap()、checkedSet()、checkedSortedMap()和checkedSortedSet()。

* 受检查的容器在你试图插入类型不正确的对象时抛出ClassCastException。
* P410

####14.异常
* 由于擦除的原因，将泛型应用于异常是非常受限的，catch语句不能捕获泛型类型的异常，因为在编译器和运行时都必须知道异常的确切类型。泛型也不能直接或间接继承自Throwable（这将进一步阻止你去定义不能捕获的泛型异常）。
* 但是，类型参数可能会在一个方法的throws子句中用到，这使得你可以编写随检查型异常的类型而发生变化的泛型代码：
* P410

####15.混型
最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。

混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。

如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点面向方面编程（AOP）的味道，而方面经常被建议用来解决混型问题。

* （1、C++中的混型
    * P412


* （2、与接口混合
    * P143


* （3、使用装饰器模式
    * 装饰器模式经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
    * 装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。
    * P414

* （4、与动态代理混合
    * 可以使用动态代理来创建一种比装饰器更贴近混型模型的机制。通过用动态代理，所产生的类的动态类型将会四已经混入的组合类型。
    * P415

####16.潜在类型机制
* 如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当“泛化”。

* 潜在类型机制/结构化类型机制（“鸭子类型机制” —— “如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当做鸭子对待。”）

* 潜在类型机制是一种代码组织和复用机制。

* P417

####17.对缺乏潜在类型机制的补偿
尽管Java不支持潜在类型机制，但是这并不意味着有界泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。

* （1、反射
    * 各个类彼此分离，没有任何公共基类（除了Object）或接口，通过反射，能够动态确定所需的方法是否可用并调用它们。
    * P420

* （2、将一个方法应用于序列
    * P421

* （3、当你并未碰巧拥有正确的接口时
    * P423

* （4、用适配器仿真潜在类型机制
    * 从我们拥有的接口中编写代码来产生我们需要的接口，这是适配器设计模式的一个典型示例。
    * 我们可以使用适配器来适配已有的接口，以产生想要的接口。
    * P424

####18.将函数对象用作策略
* 使用“策略设计模式”，可以产生更优雅的代码，因为它将“变化的事物”完全隔离到了一个函数对象中。（函数对象就是在某种程度上行为像函数的对象）
* 函数对象的价值在于，与普通方法不同，它们可以传递出去，并且还可以拥有在多个调用之间持久化的状态。当然，可以用类中的任何方法来实现与此类似的操作，但是（与使用任何设计模式一样）函数对象主要是由其目的来区别的。

* 我们创造执行适配操作的函数对象，而它们将被传递到用作策略的方法中：
* P427

####19、总结：转型真的如此之糟吗？

* 泛型正如其名称所暗示的：它是一种方法，通过它可以编写更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。

* 因为Java最初设计时没有引入泛型，导致使用它时需要承受某些痛苦，只有时间将会说明Java的泛型方式对这种语言所造成的最终影响。


###18、I/O 特别注意下NIO

* File类

* 熟悉各种类型I/O流的特点

* 字节流
    InputStream
    OutputStream
    FileInputStream
    FileOutputStream
    PipedInputStream
    PipedOutputStream
    FilterInputStream：
        * 抽象类，作为“装饰器”的接口。其中“装饰器”为其他的InputStream类提供有用功能。
    FilterOutputStream
    BufferedInputStream
        * 可以防止每次读取时都得进行实际写操作。代表“使用缓冲区”。
    BufferedOutputStream
        * 可以避免每次发送数据都要进行实际的写操作。代表“使用缓冲区”。可以调用flush()清空缓冲区。
* 字符流
    Reader
    Writer
    FileReader
    FileWriter
    PipedReader
    PipedWriter
    BufferedReader
    BufferedWriter
    
* RandomAccessFile
    seek()：将记录从一处转移到另一处，然后读取或者修改记录
    
* NIO
    * 通道与缓冲器
        * 通道要么从缓冲器获得数据、要么向缓冲器发送数据
    * FileChannel：旧I/O库中FileInputStream、FileOutputStream、RandomAccessFile可以getChannel()
    * ByteBuffer、CharBuffer……
    * Buffer又数据和可以高效地访问及操纵这些数据的四个索引组成：mark（标记）、position（位置）、limit（界限）、capacity（容量）
        * put() 和 get()被调用，position指针就会随之相应改变
        * flip()、mark()、rewind()……
* 压缩、解压

* 序列化
    * ObjectInputStream、ObjectInputStream
    * transient（瞬时）关键字

* XMl

* Preferences


###14、类型信息（反射）
* RTTI（运行时类型信息）

* Java如何让我们在运行时识别对象和类的信息的。主要有两种方式：
    * 一种是传统的“RTTI”，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制。它允许我们在运行时发现和使用类的信息。
    * 通过new创建对象和通过反射创建对象的区别：前者不能传递参数动态指定创建某个类型的对象（当然可以使用一个方法传递参数，然后根据参数创建不同对象，但很麻烦），后者有包名类名即可。

####1.为什么需要RTTI
* 通过RTTI可以查询某个引用所指向的对象的确切类型，然后选择或者剔除特列。

####2.Class对象

* 获得Class引用：
    * Class.forName()
    * getClass()
    * Xxx.class

* xxxClass.newInstance() // 由此创建实例的类必须提供默认构造器

* 使用“.class”来创建对象对Class对象的引用时，不会自动地初始化该Class对象。为了使用类而做的准备工作实际包含三个步骤：
    * （1、加载，这是由类加载器执行的，该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个Class对象。
    * （2、链接，在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用。
    * （3、初始化，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块（先域再块再构造器）。
* 初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行。


####3.类型转换前先做检查
* P323

####4.注册工厂
* P331

####5.instanceof与Class的等价性
* instanceof保持了类型的概念，它指的是“你是这个类吗，或者你是这个类的派生类吗？”而如果用==比较实际的Class对象，就没有考虑继承——它或者是这个确切的类型，或者不是。

####6.反射：运行时的类信息
* RMI（远程方法调用）：提供在跨网络的远程平台上创建和运行对象的能力

* RTTI和反射之间真正的区别只在于，对RTTI来说，编译器在编译时打开和检查.class文件（换句话说，我们可以用“普通”方式调用对象的所有方法），而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。

* 类方法提取：
    * P336

####7.动态代理
* 代理是基本的设计模式之一，它是为了提供额外的或不同的操作，而插入的用来代替“实际对象”的对象。这些操作通常涉及与“实际”对象的通信，因此代理常充当中间人的角色。
* P337

* Java的动态代理：可以动态地创建代理并动态地处理对所代理方法的调用。
    * 通过调用静态方法Proxy.newProxyInstance()可以创建动态代理，这个方法需要：
        * 1、一个类加载器
        * 2、你希望该代理实现的接口列表（不是类或抽象类）
        * 3、InvocationHandler接口的一个实现。

* P339

* 使用动态代理来编写一个系统以实现事务
* P340
* 参考oyjxDemo下的com.original.java.reflect.proxy.TransactionControl.java

####8.空对象
* 有时候引入空对象的思想将会非常有用，它可以接受传递给它的所代表的对象的消息，但是将返回表示为实际上并不存在任何“真实”对象的值。
* P341

* 如果你用接口取代具体类，那么就可以使用DynamicProxy来自动地创建空对象：
* P343

* 模拟对象与桩@Todo
* P346

####9.接口与类型信息
* 没有任何方式可以阻止反射到达并调用那些非公共访问权限的方法。对于域来说，的确如此，即便是private域。（包括内部类、匿名类）


###19、枚举
关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。

####>1.基本enum特性
* values()方法
* ordinal()方法
* compareTo()方法
* name()方法
* 可以使用==来比较enum实例，编译器会自动为你提供equals()和hashCode()方法
* Enum的静态方法valueOf()：根据给定的名字返回相应的enum实例，如果不存在给定名字的实例，将会抛出异常。
    ```
    Xxx xxx = Enum.valueOf(Xxx.class, "xxx");
    ```

* 使用static import能够将enum实例的标识符带入当前的命名空间，所以无需再用enum类型来修饰enum实例。

####2.向enum中添加新方法
* 除了不能继承自一个不enum之外，我们基本上可以将enum看作一个常规的类，也就是说我们可以向enum中添加方法，enum中甚至可以有main()方法。

####3.switch语句中的enum
* 一般来说，在switch中只能使用整数型，而枚举实例天生就具备数值的次序，并且可以通过ordinal()方法取得其次序（显然编译器帮我们做了类似的工作），因此我们可以在switch语句中使用enum

####4.values()的神秘之处
* values()是由编译器添加的static方法，在enum的基类Enum上并没有values方法。

####5.实现，而非继承
* 所有的enum都继承自java.lang.Enum类，由于Java不支持多重继承，所以你的enum不能再继承其他类。

####6.随机选取
* P596

####7.使用接口组织枚举
* P597

####8.使用EnumSet代替标志
* Java SE5引入了EnumSet，是为了通过enum创建一种替代品，以替代传统的基于int的“位标识”。
* 这种标志可以用来表示某种“开/关”信息，不过，使用这种标志，我们最终操作的只是一些bit，而不是这些bit想要表达的概念，因此很容易写出令人难以理解的代码。

* 使用EnumSet的优点是，它在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能。

* P601

* 输出顺序决定于enum实例定义时的次序。


####9.使用EnumMap
* EnumMap是一种特殊的Map，它要求其中的键（key）必须来自一个enum。

* P602

* 输出顺序决定于enum实例定义时的次序。

####10.常量相关的方法
* Java的enum有一个非常有趣的特性，即它允许程序员为enum实例编写方法，从而为每个enum实例赋予各自不同的行为。
* P603


* （1、使用enum的职责链
    * 在职责链（Chain of Responsibility）设计模式中，程序员以多种不同的方式来解决一个问题，然后将它们链接在一起，当一个请求到来时，它遍历这个链，直到链中的某个解决方案能够处理该请求。

    * 每一次尝试可以看作是一个策略，而完整的处理方式列表就是一个职责链。

    * P606

* （2、使用enum的状态机
    * 枚举类型非常适合用来创建状态机，一个状态机可以具有有限个特定的状态，它通常根据输入，从一个状态转移到下一个状态，不过也可能存在瞬时状态（transient status），而一旦任务执行结束，状态机就会立刻俩开瞬时状态。
    * P609 @Todo 代码没太明白


####11.多路分发
* Java只支持单路分发，也就是说，如果要执行的操作包含了不止一个类型未知的对象时，那么Java的动态绑定机制只能处理其中一个的类型。
* 你必须自己来判断其他的类型，从而实现自己的动态绑定行为。
* P613

* （1、使用enum分发
    * P615

* （2、使用常量相关的方法
    * P617

* （3、使用EnumMap分支
    * P618

* （4、使用二维数组
    * P619

###20、注解
注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。

####1.基本语法
* P620
* 参考oyjxDemo下的com.original.java.annotation.AnnotationDemo.java

####2.编写注解处理器
* 注解元素可以是以下类型：
    * 所有基本类型（int、float、boolean等）
    * String
    * Class
    * enum
    * Annotation
    * 以上类型的数组

* P623

* 参考oyjxDemo下的com.original.java.annotation.AnnotationDemo.java

####3.使用apt处理注解
* 注解处理工具apt，这是Sun为了帮助注解的处理过程而提供的工具。
* P629


####4.将观察者模式用于apt
* P632


####5.基于注解的单元测试
* P634 @Todo

看完注解把自己写的那个事务处理改成注解的形式哈（@Todo OK 不是很完善就是）

以后有时间熟悉熟悉使用Junit @Todo

###17、容器深入研究
* 关于hash
* 关于Map实现
* 关于迭代器 P462 Iterator（所有的Collection都实现了Iterator接口：hasNext()、next()）
    * 还有Map的迭代器 和 Entry对象理解
* 关于SoftReference、WeakReference、PhantomReference
